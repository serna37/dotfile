# =========================================================
# calculation
# =========================================================
snippet allmatch "allmatch" b
${1:alma} &= ${2};
endsnippet
snippet anymatch "anymatch" b
${1:anma} |= ${2};
endsnippet

snippet cnt_all_vec "cnt all vec" b
vector<int> cnt(${1:MAX});
for (auto &&v : ${2:A}) ++cnt[v];
endsnippet
snippet cnt_all_map "cnt all map" b
map<int, int> mp;
for (auto &&v : ${1:A}) ++mp[v];
endsnippet
snippet sum_all "sum all" b
//long long sum = 0;
//for (auto &&v : ${1:A}) sum += v;
long long sum = reduce($1.begin(), $1.end(), 0ll);
endsnippet
snippet gcd_all "gcd all" b
long long GCD = 0;
for (auto &&v : ${1:A}) GCD = gcd(GCD, v);
endsnippet
snippet lcm_all "lcm all" b
long long LCM = 1;
for (auto &&v : ${1:A}) LCM = lcm(LCM, v);
endsnippet

snippet cast_int_to_ch "tochar" i
(char)(${1:v} + '0')
endsnippet
snippet cast_ch_to_i "toint" i
(int)(${1:v} - '0')
endsnippet
snippet cast "cast description" b
string -> int, ll  : stoi() stoll()
int, ll -> string  : to_string()
endsnippet

snippet mod "mod" i
${1:ans} %= ${2:MOD}
endsnippet

snippet range "M個分の和 by 累積和" i
${1:S}[${2:i} + ${3:M}] - $1[$2]
endsnippet

snippet nc2 "nC2" i
${1:(long long)} ${2:val} * ($2 - 1) / 2
endsnippet
snippet tousa "等差数列の和" i
${1:(long long)} (1 + ${2:n}) * $2 / 2
endsnippet

snippet odd "odd" i
${1:i} & 1
endsnippet
snippet even "even" i
${1:i} % 2 == 0
endsnippet

snippet ceil "ceil" i
(${1:A} + ${2:B} - 1) / $2
endsnippet
snippet ceil2 "ceil2" i
(${1:A} + 1) / 2
endsnippet

snippet divceil "divceil" b
/*
 * 負の場合0側へ丸めない
 */
auto divCeil = []<class T>(T a, T b) -> T {
	return a / b + (((a ^ b) > 0 and a % b != 0) ? 1 : 0);
};
endsnippet
snippet divfloor "divfloor" b
/*
 * 負の場合0側へ丸めない
 */
auto divFloor = []<class T>(T a, T b) -> T {
	return a / b - (((a ^ b) < 0 and a % b != 0) ? 1 : 0);
};
endsnippet

# short logic
snippet ren_max "ren max" b
// 条件を満たす、最大コンボ数
int ${1:ren_max} = 0;
for (int ren = 0, ${2:i} = ${3:0}; $2 <${4:N}; ++$2) {
	ren = ( ${5:condition} ? ren + 1 : 0);
	$1 = max($1, ren);
}
endsnippet
snippet pattern_4 "4パターン" b
for (int ${1:k} = 0; $1 < 4; ++$1) {
	if ($1 & 1) { // x o x o
	}
	if ($1 & 2) { // x x o o
	}
}
endsnippet
snippet is_kaibun_int "回文かどうか判定" b
/*
 * 回文か判定
 */
auto isKaibun = [&](int n) -> bool {
	string tmp = to_string(n);
	string rev = tmp;
	reverse(rev.begin(), rev.end());
	return tmp == rev;
};
endsnippet
snippet is_kaibun_str "回文かどうか判定" b
/*
 * 回文か判定
 */
auto isKaibun = [](const string &s) -> bool {
	string rev = s;
	reverse(rev.begin(), rev.end());
	return s == rev;
};
endsnippet
snippet is_kakko "括弧判定" b
/*
 * 良い括弧か判定
 */
auto isKakko = [](const string &s) -> bool {
	int tmp = 0;
	bool ok = true;
	for (auto &&v : s) {
		if (v == '(') ++tmp;
		if (v == ')') --tmp;
		if (tmp < 0) ok = false;
	}
	return ok and tmp == 0;
};
endsnippet

