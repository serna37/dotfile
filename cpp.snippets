# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
# =========================================================
# Template
# =========================================================
snippet www "template cpp for AtCoder" bA
#include <bits/stdc++.h>
using namespace std;
int main() {
	${1}
}
endsnippet

# =========================================================
# grammer
# =========================================================
snippet fori "fori" b
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	${4}
}
endsnippet

snippet fori_re "fori reverse" b
for (int ${1:i} = ${2:N-1}; $1 >=${3:0}; $1--) {
	${4}
}
endsnippet

snippet forv "for vector" b
for (${1:auto} ${2:v} : ${3:A}) {
	${4}
}
endsnippet

snippet func "function" b
${1:void} ${2:func}(${3:int n}) {
	${4}
}
endsnippet

snippet func_lambda "function lambda" b
auto ${1:func} = [${2:&}](${3:int a}) -> ${4:void} {
	${5}
};
endsnippet

snippet func_lambda_recursive "function recursive" b
auto ${1:func} = [${2:&}](auto self, ${3:int a}) -> ${4:void} {
	${5}
	self(self, args); // recursive
};
endsnippet

# =========================================================
# type
# =========================================================
snippet ll "long long" bi
long long 
endsnippet

snippet dou "double" bi
double 
endsnippet

snippet vec "vec" bi
vector<${1:int}>${2}
endsnippet

snippet st "set" bi
set<${1:int}>${2}
endsnippet

snippet mul "mul" bi
multiset<${1:int}>${2}
endsnippet

snippet mp "map" bi
map<${1:int}, ${2:int}>${3}
endsnippet

snippet pp "pair" bi
pair<${1:int}, ${2:int}>${3}
endsnippet

snippet tu "tuple" bi
tuple<${1}>
endsnippet

snippet sta "stack" bi
stack<${1}>${2}
endsnippet

snippet qu "queue" bi
queue<${1}>${2}
endsnippet

snippet pri "priority_queue" bi
priority_queue<${1}>${2}
endsnippet

# =========================================================
# const
# =========================================================
snippet ww_const_PI "PI" b
const double PI = acos(-1);
endsnippet

snippet ww_const_INFINITY_INT "INFINITY" b
const int INF = 1001001001;
endsnippet

snippet ww_const_INFINITY_LONG "INFINITY" b
const long long INF = 1001001001001001001ll;
endsnippet

snippet ww_const_MOD_998244353 "mod" b
const int MOD = 998244353;
endsnippet

snippet ww_const_MOD_100000007 "mod" b
const int MOD = 1000000007;
endsnippet

snippet ww_const_grid_connector4 "grid connector" b
vector<int> dx = {0, 1, 0, -1};
vector<int> dy = {1, 0, -1, 0};
endsnippet

snippet ww_const_grid_connector8 "grid connector" b
vector<int> dx = {0, 1, 0, -1, 1, -1, 1, -1};
vector<int> dy = {1, 0, -1, 0, 1, 1, -1, -1};
endsnippet

# =========================================================
# STL
# =========================================================
snippet ww_stl_cout "ccout" b
cout << ${1:ans} << endl;
endsnippet

snippet ww_stl_fix_setprecision "fixed precision" b
cout << fixed << setprecision(${1:20});
endsnippet

snippet ww_stl_max_ch "max" b
${1:ans} = max($1, ${2:tmp});
endsnippet

snippet ww_stl_min_ch "min" b
${1:ans} = min($1, ${2:tmp});
endsnippet

snippet ww_stl_all "iterator all" bi
${1:A}.begin(), $1.end()
endsnippet

snippet ww_stl_all_rev "iterator reverse" bi
${1:A}.rbegin(), $1.rend()
endsnippet

snippet ww_stl_transform "transform" b
std::transform(${1:str}.begin(), $1.end(), $1.begin(), ::${2:tolower});
endsnippet

snippet ww_stl_uni "unique" b
sort(${1:A}.begin(), $1.end());
$1.erase(unique($1.begin(), $1.end()), $1.end());
endsnippet

# =========================================================
# builtin
# =========================================================
snippet __builtin_ctz "__builtin_ctz" bi
__builtin_ctz(${1})
endsnippet

snippet __builtin_popcount "__builtin_popcount" bi
__builtin_popcount(${1})
endsnippet

snippet __builtin_popcountll "__builtin_popcountll" bi
__builtin_popcountll(${1})
endsnippet

# =========================================================
# util function
# =========================================================
snippet ww_util_debug_vec_cout "debug for" b
cout << "debug_${1:A}:"; // TODO debug
for (auto v : $1) cout << " " << v; // TODO debug
cout << endl; // TODO debug
endsnippet

snippet ww_util_div_to_floor "div floor" b
auto divFloor = []<class T>(T a, T b) -> T {
	return a / b - (((a ^ b) < 0 and a % b != 0) ? 1 : 0);
};
endsnippet

snippet ww_util_div_to_ceil "div ceil" b
auto divCeil = []<class T>(T a, T b) -> T {
	return a / b + (((a ^ b) > 0 and a % b != 0) ? 1 : 0);
};
endsnippet

snippet ww_util_split_string "split" b
auto split = [](string s, char c) -> vector<string> {
	vector<string> S;
	string t;
	for (char v : s) {
		if (v == c) {
			if (!t.empty()) {
				S.push_back(t);
			}
			t.clear();
		} else {
			t += v;
		}
	}
	if (!t.empty()) {
		S.push_back(t);
	}
	return S;
};
endsnippet

# =========================================================
# Algorithm Math
# =========================================================
snippet ww_algo_order_sum_n "order sum" b
auto digitsum = []<class T>(T a, int N = 10) -> T {
	T ans = 0;
	while (a != 0) {
		ans += a % N;
		a /= N;
	}
	return ans;
};
endsnippet

snippet ww_algo_is_prime "is prime" b
auto is_p = []<class T>(T num) -> bool {
	if (num == 2) {
		return true;
	}
	if (num < 2 || num % 2 == 0) {
		return false;
	}
	double sqrtNum = sqrt(num);
	for (T i = 3; i <= sqrtNum; i += 2) {
		if (num % i == 0) {
			return false;
		}
	}
	return true;
};
endsnippet

snippet ww_algo_eratosthenes_sieve "sieve of eratosthenes" b
auto eratosthenes = []<class T>(T N) -> vector<bool> {
	vector<bool> is_P(N + 1, true);
	is_P[0] = is_P[1] = false;
	for (T i = 2; i * i <= N; i++) {
		if (!is_P[i]) {
			continue;
		}
		for (T j = i * i; j <= N; j += i) {
			is_P[j] = false;
		}
	}
	return is_P;
};
endsnippet

snippet ww_algo_prime_fact "prime fact" b
auto p_fact = []<class T>(T N) -> map<T, int> {
	map<T, int> P;
	for (T i = 2; i * i <= N; i++) {
		while (N % i == 0) {
			P[i]++;
			N /= i;
		}
	}
	if (N > 1) {
		P[N]++;
	}
	return P;
};
endsnippet

snippet ww_algo_mod_pow "pow mod" b
auto mod_pow = [&](long long a, long long n) -> long long {
	long long res = 1;
	while (n > 0) {
		if (n & 1) {
			res = res * a % MOD;
		}
		a = a * a % MOD;
		n >>= 1ll;
	}
	return res;
};
endsnippet

snippet ww_algo_mod_inverse_Fermat "inverse mod Fermat" b
auto modinv_fermat = [&](long long a) -> long long {
	return mod_pow(a, MOD - 2);
};
endsnippet

snippet ww_algo_mod_factorial "factorial mod" b
vector<long long> mf;
auto modfact = [&](int x) -> long long {
	if (mf.size() > x) {
		return mf[x];
	}
	if (mf.empty()) {
		mf.push_back(1);
	}
	for (int i = mf.size(); i <= x; i++) {
		long long next = mf.back() * i % MOD;
		mf.push_back(next);
	}
	return mf[x];
};
endsnippet

snippet ww_algo_factorial "factorial" b
auto factorial = []<class T>(T N) -> T {
	T ans = 1;
	while (N > 0) {
		ans *= N;
		N--;
	}
	return ans;
};
endsnippet

snippet ww_algo_mod_combination "combination mod" b
auto mod_combination = [&](int n, int k) -> long long {
	return modfact(n) * modinv_fermat(modfact(k)) % MOD * modinv_fermat(modfact(n - k)) % MOD;
};
endsnippet

snippet ww_algo_mod_combination_Euclid "combination mod Extended Euclid" b
const int MAX = 3e5;
long long fac[MAX], finv[MAX], inv[MAX];
auto Extended_Euclid_inverse_calc = [&]() -> void {
	fac[0] = fac[1] = 1;
	finv[0] = finv[1] = 1;
	inv[1] = 1;
	for (int i = 2; i < MAX; i++) {
		fac[i] = fac[i - 1] * i % MOD;
		inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;
		finv[i] = finv[i - 1] * inv[i] % MOD;
	}
};
Extended_Euclid_inverse_calc();
auto nCk = [&](int n, int k) -> long long {
	if (n < k or n < 0 or k < 0) {
		return 0;
	}
	return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
};
endsnippet

# =========================================================
# Algorithm Search
# =========================================================
snippet ww_algo_alma "allmatch" b
bool alma = true;
alma &= ;
endsnippet

snippet ww_algo_anma "anymatch" b
bool anma = false;
anma |= ;
endsnippet

snippet ww_algo_permu_loop "next permutation" b
do {${2}} while (next_permutation(${1:A}.begin(), $1.end()));
endsnippet

snippet ww_algo_bit_loop "bit loop" b
for (int bit = 0; bit < 1 << ${1:N}; bit++) {
	${2:long long} tmp = 0;
	for (int k = 0; k < $1; k++) {
		if (bit & (${3:1ll} << k)) {
			tmp |= ${4:A}[k];
		}
	}
	${5}
}
endsnippet

snippet ww_algo_bit_on_all_pattern "bit on all pattern" b
for (long long i = ${1:N}; i > 0; i = (i - 1) & $1) {
	cout << $1 - i << endl;
}
cout << $1 << endl;
endsnippet

snippet ww_algo_run_length "run length syakutori" b
string ans = "";
int r = 0;
for (int l = 0; l < ${1:N}; l++) {
	l = r;
	if (l >= $1) {
		break;
	}
	while (r < $1 and ${2:S}[l] == $2[r]) {
		++r;
	}
	ans += $2[l] + to_string(r - l);
}
${3}
endsnippet

# =========================================================
# Algorithm Graph
# =========================================================
snippet ww_algo_bfs "bfs" b
vector<bool> vis(${3:N});
queue<${1:int}> q;
q.push(${2:initial q});
while (!q.empty()) {
	auto v = q.front();
	q.pop();
	if (vis[v]) {
		continue;
	}
	vis[v] = true;
	for (int n : ${4:G}[v]) {
		q.push(n);
	}
}
${5}
endsnippet

snippet ww_algo_grid_filter "bfs grid filter" b
if (${1:x} < 0 or ${2:y} < 0 or ${3:column} <= $1 or ${4:row} <= $2) {
	continue;
}
endsnippet

# =========================================================
# Algorithm DP
# =========================================================
# TODO DELETE
snippet ww_algo_dp_napsack "dp napsack support" b
vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
for (int i = 0; i < N; i++) {
	int wi = weight[i];
	int vi = value[i];
	for (int w = 0; w <= W; ++w) {
		if (w < wi) {
			dp[i + 1][w] = dp[i][w];
		} else {
			dp[i + 1][w] = max(dp[i][w], dp[i][w - wi] + vi);
		}
	}
}
endsnippet

# TODO DELETE
snippet ww_algo_dp_sum_partial "dp partial sum support" b
vector<vector<int>> dp(N + 1, vector<int>(K + 1, false));
dp[0][0] = true;
for (int i = 0; i < N; i++) {
	int ai = A[i];
	for (int k = 0; k <= K; ++k) {
		dp[i + 1][k] = dp[i][k];
		if (k >= ai) {
			dp[i + 1][k] = dp[i][k] or dp[i][k - ai];
		}
	}
}
endsnippet

# =========================================================
# Algorithm RxQ
# =========================================================
snippet ww_algo_zeta "ruisekiwa" b
vector<${1:int}> ${2:Z}(${3:N} + 1);
for (int i = 0; i < $3; i++) {
	$2[i + 1] = $2[i] + ${4:A}[i];
}
${5}
endsnippet

snippet ww_algo_zeta_rev "ruisekiwa reverse" b
vector<${1:int}> ${2:R}(${3:N} + 1);
for (int i = $3 - 1; i >= 0; i--) {
	$2[i] = $2[i + 1] + ${4:A}[i];
}
${5}
endsnippet

snippet ww_algo_zeta_2D "2d ruisekiwa" b
vector<vector<${1:int}>> ${2:Z}(${3:H} + 1, vector<$1>(${4:W} + 1));
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		$2[i + 1][j + 1] = $2[i + 1][j] + ${5:A}[i][j];
	}
}
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		$2[i + 1][j + 1] += $2[i][j + 1];
	}
}
${6}
endsnippet

snippet ww_algo_moebius "diff" b
vector<${1:int}> ${2:D}(${3:N-1});
for (int i = 0; i < $3; i++) {
	$2[i] = ${4:A}[i + 1] - $4[i];
}
${5}
endsnippet

snippet ww_algo_imos "imos" b
${1:A}[${2:l}]${3:++};
$1[${4:r+1}]${5:--};
${6}
endsnippet

snippet ww_algo_compress_coordinate "compress" b
auto comp = []<class T>(vector<T> vec) -> vector<T> {
	auto v = vec;
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	for (int i = 0; i < (int)vec.size(); i++) {
		vec[i] = lower_bound(v.begin(), v.end(), vec[i]) - v.begin();
	}
	return vec;
};
endsnippet

snippet ww_algo_segment_tree "seg" b
$1 atom = ${3:INF};
vector<${1:int}> seg(${2:N} << 1, atom);
for (int i = 0; i < N; i++) {
	$1 ${4:A};
	cin >> $4;
	seg[i + $2] = $4;
}
for (int i = N - 1; i >= 0; i--) {
	${5:bind}
}
endsnippet

snippet ww_algo_segment_tree_query "seg query" b
auto vl = atom, vr = atom;
int ans = 0;
for (${2:l} += ${1:N}, ${3:r} += $1; $2 < $3; $2 >>= 1, $3 >>= 1) {
	if ($2 & 1) {
		${4:pick}
	}
	if ($3 & 1) {
		${5:pick}
	}
}
${6}
endsnippet

snippet ww_algo_segment_tree_upd "seg upd" b
seg[${2:i} += ${1:N}] = ${3:x};
while ($2 >>= 1) {
	for (auto v : seg[$2 << 1 | 0]) {
		seg[$2][v.first] += v.second;
	}
	for (auto v : seg[$2 << 1 | 1]) {
		seg[$2][v.first] += v.second;
	}
	seg[$2] = max(seg[$2 << 1 | 0], seg[$2 << 1 | 1]);
	seg[$2] = min(seg[$2 << 1 | 0], seg[$2 << 1 | 1]);
	seg[$2] = seg[$2 << 1 | 0] + seg[$2 << 1 | 1];
	seg[$2] = seg[$2 << 1 | 0] * seg[$2 << 1 | 1];
}
${4}
endsnippet

snippet old_struct_s "seg" b
template <typename T> struct SegTree {
	using F = function<T(T, T)>;
	int N;
	vector<T> node;
	F combine;
	T identify;
	SegTree(int n, F combine, T identify)
		: N(n), node(n << 1, identify), combine(combine), identify(identify){};
	T operator[](int i) {
		return node[i + N];
	}
	void build(vector<T> a) {
		for (int i = 0; i < N; i++) {
			node[i + N] = a[i];
		}
		for (int i = N - 1; i >= 0; i--) {
			node[i] = combine(node[i << 1 | 0], node[i << 1 | 1]);
		}
	}
	void set(int i, T x) {
		node[i += N] = x;
		while (i >>= 1) {
			node[i] = combine(node[i << 1 | 0], node[i << 1 | 1]);
		}
	}
	T fold(int l, int r) {
		T vl = identify, vr = identify;
		for (l += N, r += N; l < r; l >>= 1, r >>= 1) {
			if (l & 1) {
				vl = combine(vl, node[l++]);
			}
			if (r & 1) {
				vr = combine(node[--r], vr);
			}
		}
		return combine(vl, vr);
	}
};
endsnippet
