# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

# =========================================================
# Math Template
# =========================================================
snippet PI "PI" b
double PI = acos(-1);
endsnippet

snippet INFINITY "INFINITY" b
constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
endsnippet

snippet is_integer "is integer" b
auto is_integer = [&](double x) -> bool {
	return floor(x) == x;
};
endsnippet

snippet is_prime "is prime" b
auto is_prime = [&](int num) -> bool {
	if (num == 2) {
		return true;
	}
	if (num < 2 || num % 2 == 0) {
		return false;
	}

	double sqrtNum = sqrt(num);
	for (int i = 3; i <= sqrtNum; i += 2) {
		if (num % i == 0) {
			return false;
		}
	}
	return true;
};
endsnippet

snippet eratosthenes_sieve "sieve if eratosthenes" b
vector<int> is_P(N + 1, true);
is_P[0] = is_P[1] = false;
for (int i = 2; i * i <= N; ++i) {
	if (!is_P[i]) {
		continue;
	}
	for (int j = i * i; j <= N; j += i) {
		is_P[j] = false;
	}
}
endsnippet

snippet matrix "matrix" b
// int a[n][m];
// int b[m][l];
// ll ans[n][m];
for (int i=0; i<n; ++i) {
	for (int ii=0; ii<l; ++ii) {
		// calc
		ll calc=0;
		for (int pp=0; pp<m; ++pp) {
			calc += a[i][pp]*b[pp][ii];
		}
		ans[i][ii] = calc;
	}
}
endsnippet

snippet distance "distance" b
auto distance = [](int x1, int y1, int x2, int y2) -> int {
	return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
};
endsnippet

# =========================================================
# in / out
# =========================================================
snippet arrin "arr in" b
int N;
cin >> N;
vector<int> A(N);
rep(i, N) cin >> A[i];
endsnippet

snippet ccout "cout" b
cout << ${1:variable} << endl;
endsnippet

# =========================================================
# STL
# =========================================================
snippet ascii "ascii" b
// A : 65
// B : 66
// ...
// Z : 90
// [ : 91
// ...
// a : 97
// b : 98
// ...
// z : 122
endsnippet

snippet trans "transform" b
std::transform(ALL(${1:str}), $1.begin(), ::${2:tolower});
endsnippet

snippet sort_Arr_Asc "asc" b
sort(${1:arr}, $1+${2:n});
endsnippet

snippet sort_Arr_Desc "desc" b
sort(${1:arr}, $1+${2:n}, greater<${3:int}>());
endsnippet

snippet sort_Asc "asc" b
sort(ALL(${1:s}));
endsnippet

snippet sort_Desc "desc" b
sort(${1:s}.rbegin(), $1.rend());
endsnippet

snippet reverse_Vec "reverse vector" b
reverse(ALL(${1:A}));
endsnippet

snippet reverse_Arr "reverse arr" b
reverse(${1:arr}, $1 + ${2:length});
endsnippet

snippet reverse_Str "reverse string" b
reverse(ALL(${1:str}));
endsnippet

snippet uni "unique" b
sort(ALL(${1:A}));
A.erase(unique(ALL($1)), $1.end());
endsnippet

snippet count_Vec "count vector" biw
count(ALL(${1:A}), ${2:chk_val});
endsnippet

snippet find_Vec "find vector" biw
find(ALL(${1:A}), ${2:chk_val}) != $1.end();
endsnippet

snippet nextperm "next_permutation" biw
next_permutation(ALL(${1:vector}))
endsnippet

snippet lowe "lower bound" biw
lower_bound(ALL(${1:A}), ${2:chk});
endsnippet

# =========================================================
# basic algo
# =========================================================
snippet maxVal "maxVal" b
int ${1:maxVal} = 0;
rep(i, ${2:N}) {
	$1 = max($1, ${3:A}[i]);
}
endsnippet

snippet minVal "minVal" b
int ${1:minVal} = 1e9 + 7;
rep(i, ${2:N}) {
	$1 = min($1, ${3:A}[i]);
}
endsnippet

snippet allmatch "allmatch" b
bool allmatchFlg = true;
// for
// allmatchFlg &= true condition
endsnippet

snippet anymatch "anymatch" b
bool anymatchFlg = false;
// for
// anymatchFlg |= true condition
endsnippet

# =========================================================
# Algorithm
# =========================================================
snippet bfs_1d_template "bfs support" b
vector<vector<int>> con(N, vector<int>(1, 0));
queue<int> q;
vector<int> dist(N, -1);
//vector<bool> used(N, false);
//vector<int> counter(N + 1, 0);

rep(i, N) {
	int a, b;
	cin >> a >> b;
	con[a].push_back(b);
	con[b].push_back(a);
}

q.push(0);
dist[0] = 0;

while (!q.empty()) {
	int current_vertex = q.front();
	q.pop();
	for (int next_vertex : con[current_vertex]) {
		if (dist[next_vertex] != 1) {
			dist[next_vertex] = dist[current_vertex] + 1;
			q.push(next_vertex);
		}
	}
}
endsnippet

snippet bfs_2d_template "bfs support" b
//vector<string> Grid(row);
vector<vector<char>> Grid(row, vector<char>(column));
vector<int> dx4 = {1, 0, -1, 0};
vector<int> dy4 = {0, 1, 0, -1};
vector<int> dx8 = {-1, -1, -1, 0, 0, 1, 1, 1};
vector<int> dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};
queue<pi> q;
vector<vector<bool>> used(row, vector<bool>(column, false));
//vector<vector<int>> dist(row, vector<int>(column, -1));

q.push({0, 0});
used[0][0] = true;
//dist[0][0] = 0;

while (!q.empty()) {
	pi current_xy = q.front();
	q.pop();
	for (int i = 0; i < 8; ++i) {
		int x = dx8[i] + current_xy.first;
		int y = dy8[i] + current_xy.second;
		// only in range
		if (x < 0 or y < 0 or column <= x or row <= y) {
			continue;
		}
		// un visited, can go
		if (!used[x][y] and Grid[x][y] == '#') {
			q.push({x, y});
			used[x][y] = true;
			//dist[x][y] = dist[current_xy.first][current_xy.second] + 1;
		}
	}
}
endsnippet

snippet running_total "running total" b
vector<int> ${1:runsum}(N + 1, 0);
rep(i, N) {
	$1[i + 1] = $1[i] + A[i];
}
endsnippet

snippet dp_napsack "dp napsack support" b
vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
for (int i = 0; i < N; ++i) {
	int wi = weight[i];
	int vi = value[i];
	for (int w = 0; w <= W; ++w) {
		if (w < wi) {
			dp[i + 1][w] = dp[i][w];
		} else {
			dp[i + 1][w] = max(dp[i][w], dp[i][w - wi] + vi);
		}
	}
}
endsnippet

snippet dp_sum_partial "dp partial sum support" b
vector<vector<int>> dp(N + 1, vector<int>(K + 1, false));
dp[0][0] = true;
for (int i = 0; i < N; ++i) {
	int ai = A[i];
	for (int k = 0; k <= K; ++k) {
		dp[i + 1][k] = dp[i][k];
		if (k >= ai) {
			dp[i + 1][k] = dp[i + 1][k] or dp[i][k - ai];
		}
	}
}
endsnippet

snippet cmopress "compress" b
auto compress = []<class T>(vector<T> &vec) -> void {
	auto v = vec;
	sort(ALL(v));
	v.erase(unique(ALL(v)), v.end());

	rep(i, vec.size()) {
		vec[i] = lower_bound(ALL(v), vec[i]) - v.begin();
	}
};
endsnippet

# =========================================================
# grammer
# =========================================================
snippet fori "for" b
for (${1:int} ${2:i}=${3:0}; $2<${4:N}; ${5:++$2}) {
	${6}
}
endsnippet

snippet forv "for vector" b
for (auto& ${1:v} : ${2:a}) {
	${3}
}
endsnippet

snippet re "simple repeat" b
${1:rep}(${2:i}, ${3:N}) {
	${4}
}
endsnippet

snippet func "function" b
${1:void} func(${2:int n}) {
	${3}
}
endsnippet

snippet func_lambda "function lambda" b
auto ${1:func} = [&](${2:int a}) -> ${3:void} {
	${4}
};
endsnippet

snippet func_recursive "function recursive" b
auto ${1:func} = [&](auto self, ${2:int a}) -> ${3:void} {
	${4}
	self(self, _); // recursive
};

// TODO
$1($1, );
endsnippet

# =========================================================
# Template
# =========================================================
snippet xxx "template cpp for AtCoder" b
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pi = pair<int, int>;
#define rep(i, N) for (int i = 0; i < (int)(N); ++i)
#define repl(i, N) for (ll i = 0; i < (ll)(N); ++i)
#define ALL(a) (a).begin(), (a).end()

int main() {
	${1}

	// cout << fixed << setprecision(5);

	return 0;
}
endsnippet

