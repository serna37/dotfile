# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
# =========================================================
# Template
# =========================================================
snippet www "template cpp for AtCoder" bA
#include <bits/stdc++.h>
using namespace std;
int main() {
	${1}
}
endsnippet

# =========================================================
# grammer
# =========================================================
snippet fori "fori" b
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	${4}
}
endsnippet

snippet fori_re "fori reverse" b
for (int ${1:i} = ${2:N-1}; $1 >=${3:0}; $1--) {
	${4}
}
endsnippet

snippet forv "for vector" b
for (${1:auto} ${2:v} : ${3:A}) {
	${4}
}
endsnippet

snippet func "function" b
${1:void} ${2:func}(${3:int n}) {
	${4}
}
endsnippet

snippet func_lambda "function lambda" b
auto ${1:func} = [${2:&}](${3:int a}) -> ${4:void} {
	${5}
};
endsnippet

snippet func_lambda_recursive "function recursive" b
auto ${1:func} = [${2:&}](auto self, ${3:int a}) -> ${4:void} {
	${5}
	self(self, args); // recursive
};
endsnippet

# =========================================================
# type
# =========================================================
snippet ll "long long" bi
long long 
endsnippet

snippet dou "double" bi
double 
endsnippet

snippet vec "vec" bi
vector<${1:int}>${2}
endsnippet

snippet st "set" bi
set<${1:int}>${2}
endsnippet

snippet mp "map" bi
map<${1:int}, ${2:int}>${3}
endsnippet

snippet pp "pair" bi
pair<${1:int}, ${2:int}>${3}
endsnippet

snippet sta "stack" bi
stack<${1}>${2}
endsnippet

snippet qu "queue" bi
queue<${1}>${2}
endsnippet

snippet pri "priority_queue" bi
priority_queue<${1}>${2}
endsnippet

# =========================================================
# const
# =========================================================
snippet w_const_PI "PI" b
const double PI = acos(-1);
endsnippet

snippet w_const_INFINITY_INT "INFINITY" b
const int INF = 1001001001;
endsnippet

snippet w_const_INFINITY_LONG "INFINITY" b
const long long INF = 1001001001001001001ll;
endsnippet

snippet w_const_MOD_998244353 "mod" b
const int MOD = 998244353;
endsnippet

snippet w_const_MOD_100000007 "mod" b
const int MOD = 1000000007;
endsnippet

snippet w_const_grid_connector4 "grid connector" b
vector<int> dx = {0, 1, 0, -1};
vector<int> dy = {1, 0, -1, 0};
endsnippet

snippet w_const_grid_connector8 "grid connector" b
vector<int> dx = {0, 1, 0, -1, 1, -1, 1, -1};
vector<int> dy = {1, 0, -1, 0, 1, 1, -1, -1};
endsnippet

# =========================================================
# STL
# =========================================================
snippet w_stl_cout "ccout" b
cout << ${1:ans} << endl;
endsnippet

snippet w_stl_fix_precision "fixed precision" b
cout << fixed << setprecision(${1:10});
endsnippet

snippet w_stl_max "max" b
${1:ans} = max($1, ${2:tmp});
endsnippet

snippet w_stl_min "min" b
${1:ans} = min($1, ${2:tmp});
endsnippet

snippet w_stl_ALL "iterator all" bi
${1:A}.begin(), $1.end()
endsnippet

snippet w_stl_ALL_rev "iterator reverse" bi
${1:A}.rbegin(), $1.rend()
endsnippet

snippet w_stl_transform "transform" b
std::transform(${1:str}.begin(), $1.end(), $1.begin(), ::${2:tolower});
endsnippet

snippet w_stl_uni "unique" b
sort(${1:A}.begin(), $1.end());
$1.erase(unique($1.begin(), $1.end()), $1.end());
endsnippet

# =========================================================
# util function
# =========================================================
snippet w_util_div_to_floor "div floor" b
auto divFloor = [](${1:int} a, $1 b) -> $1 {
	return a / b - (((a ^ b) < 0 and a % b != 0) ? 1 : 0);
};
endsnippet

snippet w_util_div_to_ceil "div ceil" b
auto divCeil = [](${1:int} a, $1 b) -> $1 {
	return a / b + (((a ^ b) > 0 and a % b != 0) ? 1 : 0);
};
endsnippet

snippet w_util_split_string "split" b
auto split = [](string s, char c) -> vector<string> {
	vector<string> S;
	string t;
	for (char v : s) {
		if (v == c) {
			if (!t.empty()) {
				S.push_back(t);
			}
			t.clear();
		} else {
			t += v;
		}
	}
	if (!t.empty()) {
		S.push_back(t);
	}
	return S;
};
endsnippet

# =========================================================
# Algorithm Math
# =========================================================
snippet w_algo_order_sum_n "order sum" b
auto digitsum = [](${1:int} a, int N = 10) -> int {
	int ans = 0;
	while (a != 0) {
		ans += a % N;
		a /= N;
	}
	return ans;
};
endsnippet

snippet w_algo_is_prime "is prime" b
auto is_p = [](${1:int} num) -> bool {
	if (num == 2) {
		return true;
	}
	if (num < 2 || num % 2 == 0) {
		return false;
	}
	double sqrtNum = sqrt(num);
	for ($1 i = 3; i <= sqrtNum; i += 2) {
		if (num % i == 0) {
			return false;
		}
	}
	return true;
};
endsnippet

snippet w_algo_eratosthenes_sieve "sieve of eratosthenes" b
auto eratosthenes = [](${1:int} N) -> vector<bool> {
	vector<bool> is_P(N + 1, true);
	is_P[0] = is_P[1] = false;
	for ($1 i = 2; i * i <= N; i++) {
		if (!is_P[i]) {
			continue;
		}
		for ($1 j = i * i; j <= N; j += i) {
			is_P[j] = false;
		}
	}
	return is_P;
};
endsnippet

snippet w_algo_prime_fact "prime fact" b
auto p_fact = [](${1:int} N) -> map<$1, int> {
	map<$1, int> P;
	for ($1 i = 2; i * i <= N; i++) {
		while (N % i == 0) {
			P[i]++;
			N /= i;
		}
	}
	if (N > 1) {
		P[N]++;
	}
	return P;
};
endsnippet

snippet w_algo_mod_pow "mod pow" b
auto modpow = [](long long a, long long n, long long mod) -> long long {
	long long res = 1;
	while (n > 0) {
		if (n & 1) {
			res = res * a % mod;
		}
		a = a * a % mod;
		n >>= 1ll;
	}
	return res;
};
endsnippet

snippet w_algo_inverse_Fermat "Fermat" b
auto modinv = [&](long long a, long long mod) -> long long {
	return modpow(a, mod - 2, mod);
};
endsnippet

# TODO modify
snippet w_algo_inverse_Euclid "extended Euclid" b
auto modinv = [](long long a, long long m) -> long long {
	long long b = m, u = 1, v = 0;
	while (b) {
		long long t = a / b;
		a -= t * b;
		swap(a, b);
		u -= t * v;
		swap(u, v);
	}
	u %= m;
	if (u < 0) u += m;
	return u;
};
endsnippet

# =========================================================
# Algorithm Search
# =========================================================
snippet w_algo_compress_coordinate "compress" b
auto comp = []<class T>(vector<T> vec) -> vector<T> {
	auto v = vec;
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	for (int i = 0; i < (int)vec.size(); i++) {
		vec[i] = lower_bound(v.begin(), v.end(), vec[i]) - v.begin();
	}
	return vec;
};
endsnippet

snippet w_algo_permu_loop "next permutation" b
do {${2}} while (next_permutation(${1:A}.begin(), $1.end()));
endsnippet

snippet w_algo_bit_loop "bit loop" b
for (int bit = 0; bit < 1 << ${1:N}; bit++) {
	${2:long long} tmp = 0;
	for (int k = 0; k < $1; k++) {
		if ($1 & (${3:1ll} << k)) {
			tmp |= ${4:A}[k];
		}
	}
	${5}
}
endsnippet

snippet w_algo_run_length "run length syakutori" b
int ans = 0;
int r = 0;
for (int l = 0; l < ${1:N}; l++) {
	while (r < $1 and ${2:A}[r] == $2[l]}) {
		++r;
	}
	ans = max(ans, r - l);
}
${3}
endsnippet

# =========================================================
# Algorithm Graph
# =========================================================
# TODO
snippet w_algo_bfs "bfs" b
while (!${1:q}.empty()) {
	auto a = $1.front();
	$1.pop();
	for (int v : ${2:G}[a]) {
		$1.push(v);
	}
}
${3}
endsnippet

snippet w_algo_grid_filter "bfs grid filter" b
if (${1:x} < 0 or ${2:y} < 0 or ${3:column} <= $1 or ${4:row} <= $2) continue;
endsnippet

# =========================================================
# Algorithm DP
# =========================================================
# TODO DELETE
snippet w_algo_dp_napsack "dp napsack support" b
vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
for (int i = 0; i < N; i++) {
	int wi = weight[i];
	int vi = value[i];
	for (int w = 0; w <= W; ++w) {
		if (w < wi) {
			dp[i + 1][w] = dp[i][w];
		} else {
			dp[i + 1][w] = max(dp[i][w], dp[i][w - wi] + vi);
		}
	}
}
endsnippet

# TODO DELETE
snippet w_algo_dp_sum_partial "dp partial sum support" b
vector<vector<int>> dp(N + 1, vector<int>(K + 1, false));
dp[0][0] = true;
for (int i = 0; i < N; i++) {
	int ai = A[i];
	for (int k = 0; k <= K; ++k) {
		dp[i + 1][k] = dp[i][k];
		if (k >= ai) {
			dp[i + 1][k] = dp[i][k] or dp[i][k - ai];
		}
	}
}
endsnippet

# =========================================================
# Algorithm RxQ
# =========================================================
snippet w_algo_ruiseki_abc "ruisekiwa" b
vector<${1:int}> ${2:S}(${3:N} + 1);
for (int i = 0; i < $3; i++) {
	$2[i + 1] = $2[i] + ${4:A}[i];
}
${5}
endsnippet

snippet w_algo_ruiseki_rev "ruisekiwa reverse" b
vector<${1:int}> ${2:R}(${3:N} + 1);
for (int i = $3 - 1; i >= 0; i--) {
	$2[i] = $2[i + 1] + ${4:A}[i];
}
${5}
endsnippet

snippet w_algo_imos "imos" b
${1:A}[${2:l}]${3:++};
$1[${4:r+1}]${5:--};
${6}
endsnippet

# TODO fix
snippet w_algo_Seg_RMQ "Segment Tree RMQ" b
class SegmentTreeRMQ {
	const static long long ll_MAX = (1LL << 31) - 1;
	int n_0; long long seg_tree[4 * 100007];
  public:
	SegmentTreeRMQ(int n) {
		n_0 = 1; while (n_0 < n) n_0 <<= 1;
		for (int i = 0; i < 2 * n_0; i++) {
			seg_tree[i] = ll_MAX;
		}
	}
	void update(int idx, long long val) {
		idx += n_0 - 1; seg_tree[idx] = val;
		while (idx > 0) { idx = (idx - 1) / 2; seg_tree[idx] = min(seg_tree[2 * idx + 1], seg_tree[2 * idx + 2]); }
	}
	long long query(int l, int r) {
		int l_0 = l + n_0, r_0 = r + n_0; long long s = ll_MAX;
		while (l_0 < r_0) { if (r_0 & 1) { --r_0; s = min(s, seg_tree[r_0 - 1]); }
			if (l_0 & 1) { s = min(s, seg_tree[l_0 - 1]); ++l_0; }
			l_0 >>= 1; r_0 >>= 1; } return s;
	}
};
endsnippet

