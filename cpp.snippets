# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
# =========================================================
# Template
# =========================================================
snippet www "template header" bA
#include <bits/stdc++.h>
using namespace std;
${1}
endsnippet

snippet main "main function" b
int main() {
	${1}
}
endsnippet

# =========================================================
# grammer
# =========================================================
snippet for "for" b
for (${1} ; ${2} ; ${3}) {
	${4}
}
endsnippet

snippet fori "fori" b
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	${4}
}
endsnippet

snippet forl "forl" b
for (long long ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	${4}
}
endsnippet

snippet fori_re "fori reverse" b
for (int ${1:i} = ${2:N-1}; $1 >=${3:0}; $1--) {
	${4}
}
endsnippet

snippet foril_sqrt "foril sqrt" b
for (long long ${1:i} = ${2:0}; $1 * $1 <= ${3:N}; $1++) {
	${4}
}
endsnippet

snippet fori2 "fori 2" b
for (int ${1:i} = ${2:0}; $1 <${3:H}; $1++) {
	for (int ${4:j} = ${5:0}; $4 <${6:W}; $4++) {
		${7}
	}
}
endsnippet

snippet forv "for vector" b
for (${1:auto} ${2:&v} : ${3:A}) {
	${4}
}
endsnippet

snippet func "function" b
${1:void} ${2:func}(${3:int n}) {
	${4}
}
endsnippet

snippet func_lambda "function lambda" b
auto ${1:func} = [${2:&}](${3:const int &a}) -> ${4:void} {
	${5}
};
endsnippet

snippet func_lambda_recursive "function recursive" b
auto ${1:func} = [${2:&}](auto self, ${3:const int &a}) -> ${4:void} {
	${5}
	self(self, args); // recursive
};
endsnippet

# =========================================================
# type
# =========================================================
snippet ll "long long" bi
long long 
endsnippet

snippet dou "double" bi
double 
endsnippet

snippet vec "vec" bi
vector<${1:int}>
endsnippet

snippet st "set" bi
set<${1:int}>
endsnippet

snippet mul "mul" bi
multiset<${1:int}>
endsnippet

snippet mp "map" bi
map<${1:int}, ${2:int}>
endsnippet

snippet uno "unordered_map" bi
unordered_map<${1:int}, ${2:int}>
endsnippet

snippet pp "pair" bi
pair<${1:int}, ${2:int}>
endsnippet

snippet tu "tuple" bi
tuple<${1}>
endsnippet

snippet sta "stack" bi
stack<${1:int}>
endsnippet

snippet qu "queue" bi
queue<${1:int}>
endsnippet

snippet pri "priority_queue" bi
priority_queue<${1:int}>
endsnippet

snippet deq "deque" bi
deque<${1:char}>
endsnippet

snippet uf "union find" bi
UnionFind uf(${1:N});
endsnippet

snippet rqmin "RxQ min" bi
RxQmin<${1:int}>
endsnippet

snippet rqmax "RxQ max" bi
RxQmax<${1:int}>
endsnippet

snippet rqsum "RxQ sum" bi
RxQsum<${1:int}>
endsnippet

snippet rqprod "RxQ prod" bi
RxQprod<${1:int}>
endsnippet

snippet rqgcd "RxQ gcd" bi
RxQgcd<${1:int}>
endsnippet

snippet seg "seg" bi
SegTree<${1}> seg(${2:N});
endsnippet

snippet fwk "fwk" bi
FwkTree<${1}> fwk(${2:N});
endsnippet

# =========================================================
# const
# =========================================================
snippet ww_const_PI "PI" b
const double PI = acos(-1);
endsnippet

snippet ww_const_INFINITY_INT "INFINITY" b
const int INF = 1001001001;
endsnippet

snippet ww_const_INFINITY_LONG "INFINITY" b
const long long INF = 1001001001001001001ll;
endsnippet

snippet ww_const_MOD_998244353 "mod" b
const long long MOD = 998244353;
endsnippet

snippet ww_const_MOD_100000007 "mod" b
const long long MOD = 1000000007;
endsnippet

snippet ww_const_grid_dydx4 "grid connector" b
const vector<int> dx = {0, 1, 0, -1};
const vector<int> dy = {1, 0, -1, 0};
endsnippet

snippet ww_const_grid_dydx8 "grid connector" b
const vector<int> dx = {0, 1, 0, -1, 1, -1, 1, -1};
const vector<int> dy = {1, 0, -1, 0, 1, 1, -1, -1};
endsnippet

# =========================================================
# IN OUT
# =========================================================
snippet ww_vec_cin_1 "vec cin" b
vector<${1:int}> ${2:A}(${3:N});
for (int i = 0; i < $3; i++) {
	cin >> $2[i];
}
endsnippet

snippet ww_vec_cin_2 "vec cin" b
vector<${1:int}> ${2:A}(${4:N}), ${3:B}($4);
for (int i = 0; i < $4; i++) {
	cin >> $2[i] >> $3[i];
}
endsnippet

snippet ww_grid_cin "grid cin" b
vector<vector<${1:char}>> ${2:G}(${3:H}, vector<$1>(${4:W}));
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		cin >> $2[i][j];
	}
}
endsnippet

snippet ww_graph_cin "graph cin" b
vector<vector<${1:int}>> ${2:G}(${3:N});
for (int i = 0; i < ${4:M}; i++) {
	$1 ${5:A}, ${6:B};
	cin >> $5 >> $6;
	$5--, $6--;
	G[$5].push_back($6);
	G[$6].push_back($5);
}
endsnippet

snippet ww_cout "cout" b
cout << ${1:ans} << endl;
endsnippet

snippet ww_cout_yes_no "yes no" b
cout << (${1:condition} ? "${2:Yes}" : "${3:No}") << endl;
endsnippet

snippet ww_fixed_setprecision "fixed precision" b
cout << fixed << setprecision(${1:20});
endsnippet

# =========================================================
# STL
# =========================================================
snippet ww_stl_max_ch "max" b
${1:ans} = max($1, ${2:tmp});
endsnippet

snippet ww_stl_min_ch "min" b
${1:ans} = min($1, ${2:tmp});
endsnippet

snippet ww_stl_all "iterator all" bi
${1:A}.begin(), $1.end()
endsnippet

snippet ww_stl_all_rev "iterator reverse" bi
${1:A}.rbegin(), $1.rend()
endsnippet

# prepare for completion priority
snippet sort "sort" b
sort(${1});
endsnippet

# prepare for completion priority
snippet swap "swap" b
swap(${1});
endsnippet

snippet ww_stl_transform "transform" b
std::transform(${1:str}.begin(), $1.end(), $1.begin(), ::${2:tolower});
endsnippet

snippet ww_stl_uni "unique" b
sort(${1:A}.begin(), $1.end());
$1.erase(unique($1.begin(), $1.end()), $1.end());
endsnippet

# =========================================================
# builtin
# =========================================================
snippet __builtin_ctz "__builtin_ctz" bi
__builtin_ctz(${1})
endsnippet

snippet __builtin_popcount "__builtin_popcount" bi
__builtin_popcount(${1})
endsnippet

snippet __builtin_popcountll "__builtin_popcountll" bi
__builtin_popcountll(${1})
endsnippet

# =========================================================
# util function
# =========================================================
snippet ans "ans" b
${1:int} ans = ${2:0};
endsnippet

snippet tmp "tmp" b
${1:int} tmp = ${2:0};
endsnippet

snippet ok "ok" b
bool ok = true;
endsnippet

snippet size "size" b
int ${1:N} = ${2:S}.size();
endsnippet

snippet size "size" iw
(int)${1:S}.size()
endsnippet

snippet ww_util_debug_vec_cout "debug for" b
cout << "debug_${1:A}:"; // TODO debug
for (auto v : $1) cout << " " << v; // TODO debug
cout << endl; // TODO debug
endsnippet

snippet ww_util_div_to_floor "div floor" b
auto divFloor = []<class T>(T a, T b) -> T {
	return a / b - (((a ^ b) < 0 and a % b != 0) ? 1 : 0);
};
endsnippet

snippet ww_util_div_to_ceil "div ceil" b
auto divCeil = []<class T>(T a, T b) -> T {
	return a / b + (((a ^ b) > 0 and a % b != 0) ? 1 : 0);
};
endsnippet

snippet ww_util_div_to_ceil_inline "div ceil" bi
(${1:N} + ${2:A} - 1) / $2
endsnippet

snippet ww_util_islow_char "is lower" b
auto islow = [](char c) -> bool {
	return islower(c) != 0;
};
endsnippet

snippet ww_util_isupp_char "is upper" b
auto isupp = [](char c) -> bool {
	return isupper(c) != 0;
};
endsnippet

snippet ww_util_split_string "split" b
auto split = [](string s, char c) -> vector<string> {
	vector<string> S;
	string t;
	for (char v : s) {
		if (v == c) {
			if (!t.empty()) S.push_back(t);
			t.clear();
		} else {
			t += v;
		}
	}
	if (!t.empty()) S.push_back(t);
	return S;
};
endsnippet

# =========================================================
# Math
# =========================================================
snippet ww_math_order_sum_n "order sum" b
auto digitsum = []<class T>(T a, int N = 10) -> T {
	T ans = 0;
	while (a != 0) {
		ans += a % N;
		a /= N;
	}
	return ans;
};
endsnippet

snippet ww_math_divisors_list "divisors" b
auto divisors = []<class T>(T a) -> vector<T> {
	vector<T> ans;
	for (int i = 1; i * i <= a; i++) {
		if (a % i != 0) continue;
		ans.push_back(i);
		if (a / i != i) ans.push_back(a / i);
	}
	return ans;
};
endsnippet

snippet ww_math_is_prime "is prime" b
auto is_p = []<class T>(T num) -> bool {
	if (num == 2) return true;
	if (num < 2 || num % 2 == 0) return false;
	double sqrtNum = sqrt(num);
	for (T i = 3; i <= sqrtNum; i += 2) {
		if (num % i == 0) return false;
	}
	return true;
};
endsnippet

snippet ww_math_prime_fact "prime fact" b
auto p_fact = []<class T>(T N) -> map<T, int> {
	map<T, int> P;
	for (T i = 2; i * i <= N; i++) {
		while (N % i == 0) {
			P[i]++;
			N /= i;
		}
	}
	if (N > 1) P[N]++;
	return P;
};
endsnippet

snippet ww_math_eratosthenes_sieve "sieve of eratosthenes" b
auto eratosthenes = []<class T>(T N) -> vector<bool> {
	vector<bool> is_P(N + 1, true);
	is_P[0] = is_P[1] = false;
	for (T i = 2; i * i <= N; i++) {
		if (!is_P[i]) continue;
		for (T j = i * i; j <= N; j += i) is_P[j] = false;
	}
	return is_P;
};
endsnippet

snippet ww_math_mod_pow "pow mod" b
auto mod_pow = [&]<class T>(T a, T n) -> T {
	T ans = 1;
	while (n > 0) {
		if (n & 1) ans = ans * a % MOD;
		a = a * a % MOD;
		n >>= 1ll;
	}
	return ans;
};
endsnippet

snippet ww_math_mod_inverse_Fermat "inverse mod Fermat" b
auto modinv_fermat = [&](long long a) -> long long {
	return mod_pow(a, MOD - 2);
};
endsnippet

snippet ww_math_mod_factorial "factorial mod" b
vector<long long> mf;
auto modfact = [&](int x) -> long long {
	if ((int)mf.size() > x) return mf[x];
	if (mf.empty()) mf.push_back(1);
	for (int i = mf.size(); i <= x; i++) mf.push_back(mf.back() * i % MOD);
	return mf[x];
};
endsnippet

snippet ww_math_factorial "factorial" b
auto factorial = []<class T>(T N) -> T {
	T ans = 1;
	while (N > 0) ans *= N--;
	return ans;
};
endsnippet

snippet ww_math_mod_combination "combination mod" b
auto mod_combination = [&](int n, int k) -> long long {
	return modfact(n) * modinv_fermat(modfact(k)) % MOD * modinv_fermat(modfact(n - k)) % MOD;
};
endsnippet

snippet ww_math_mod_combination_Euclid "combination mod Extended Euclid" b
const int MAX = 3e5;
long long fac[MAX], finv[MAX], inv[MAX];
auto Extended_Euclid_inverse_calc = [&]() -> void {
	fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;
	for (int i = 2; i < MAX; i++) {
		fac[i] = fac[i - 1] * i % MOD;
		inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;
		finv[i] = finv[i - 1] * inv[i] % MOD;
	}
};
Extended_Euclid_inverse_calc();
auto nCk = [&](int n, int k) -> long long {
	if (n < k or n < 0 or k < 0) return 0;
	return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
};
endsnippet

# =========================================================
# Algorithm Search
# =========================================================
snippet ww_algo_alma "allmatch" b
bool alma = true;
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	alma &= ${4};
}
endsnippet

snippet ww_algo_anma "anymatch" b
bool anma = false;
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	anma |= ${4};
}
endsnippet

snippet ww_algo_permu_loop "next permutation" b
do {${2}} while (next_permutation(${1:A}.begin(), $1.end()));
endsnippet

snippet ww_algo_bit_loop "bit loop" b
for (int bit = 0; bit < 1 << ${1:N}; bit++) {
	${2:long long} tmp = 0;
	for (int k = 0; k < $1; k++) {
		if (bit & (${3:1ll} << k)) {
			tmp |= ${4:A}[k];
		}
	}
}
endsnippet

snippet ww_algo_bit_on_all_pattern "bit on all pattern" b
for (long long i = ${1:N}; i > 0; i = (i - 1) & $1) {
	cout << $1 - i << endl;
}
cout << $1 << endl;
endsnippet

snippet ww_algo_run_length "run length syakutori" b
string ans = "";
int r = 0;
for (int l = 0; l < ${1:N}; l++) {
	l = r;
	if (l >= $1) {
		break;
	}
	while (r < $1 and ${2:S}[l] == $2[r]) {
		++r;
	}
	ans += $2[l] + to_string(r - l);
}
endsnippet

# =========================================================
# Algorithm Graph
# =========================================================
snippet ww_algo_bfs_graph "bfs graph" b
queue<int> q;
q.push(${1:0});
vector<int> d(${2:N}, -1);
d[$1] = 0;
while (!q.empty()) {
	int v = q.front();
	q.pop();
	for (int nv : ${3:G}[v]) {
		if (d[nv] == -1) {
			d[nv] = d[v] + 1;
			q.push(nv);
		}
	}
}
endsnippet

snippet ww_algo_bfs_grid "bfs grid" b
queue<pair<int, int>> q;
q.push({${1:sy}, ${2:sx}});
vector<vector<int>> d(${3:H}, vector<int>(${4:W}, -1));
d[$1][$2] = 0;
while (!q.empty()) {
	int py = q.front().first;
	int px = q.front().second;
	q.pop();
	for (int i = 0; i < 4; i++) {
		int y = py + dy[i];
		int x = px + dx[i];
		if (y < 0 or x < 0 or $3 <= y or $4 <= x) continue;
		if (d[y][x] == -1 and cango(${5:G}[y][x])) {
			d[y][x] = d[py][px] + 1;
			q.push({y, x});
		}
	}
}
endsnippet

snippet ww_algo_grid_cango "grid cango" b
auto cango = [](const char &a) -> bool {
	string white = "${1:.SG}";
	return white.find(a) != string::npos;
};
endsnippet

snippet ww_algo_grid_dydx "dydx" b
for (int ${1:k} = 0; $1 < ${2:4}; $1++) {
	int y = ${3:i} + dy[$1];
	int x = ${4:j} + dx[$1];
	${5}
}
endsnippet

snippet ww_algo_grid_filter "bfs grid filter" b
if (${1:y} < 0 or ${2:x} < 0 or ${3:row} <= $1 or ${4:column} <= $2) continue;
endsnippet

# =========================================================
# Algorithm DP
# =========================================================
snippet ww_algo_dp_1d "dp 1d" b
vector<${1:int}> dp(${2:N} + 1, ${3:0});
dp[${4:0}] = ${5:0};
${6:fori}
cout << dp[$2] << endl;
endsnippet

snippet ww_algo_dp_2d "dp 2d" b
vector<vector<${1:int}>> dp(${2:N} + 1, vector<$1>(${3:W} + 1, ${4:0}));
dp[${5:0}][${6:0}] = ${7:0};
${8:fori2}
cout << dp[$2][$3] << endl;
endsnippet

# =========================================================
# Algorithm Range
# =========================================================
snippet ww_algo_zeta "ruisekiwa" b
vector<${1:long long}> ${2:S}(${3:N} + 1);
for (int i = 0; i < $3; i++) {
	$2[i + 1] = $2[i] + ${4:A}[i];
}
endsnippet

snippet ww_algo_zeta_rev "ruisekiwa reverse" b
vector<${1:long long}> ${2:R}(${3:N} + 1);
for (int i = $3 - 1; i >= 0; i--) {
	$2[i] = $2[i + 1] + ${4:A}[i];
}
endsnippet

snippet ww_algo_zeta_2D "2d ruisekiwa" b
vector<vector<${1:long long}>> ${2:S}(${3:H} + 1, vector<$1>(${4:W} + 1));
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		$2[i + 1][j + 1] = $2[i + 1][j] + ${5:A}[i][j];
	}
}
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		$2[i + 1][j + 1] += $2[i][j + 1];
	}
}
endsnippet

snippet ww_algo_moebius "diff" b
vector<${1:int}> ${2:D}(${3:N-1});
for (int i = 0; i < $3; i++) {
	$2[i] = ${4:A}[i + 1] - $4[i];
}
endsnippet

snippet ww_algo_imos "imos" b
${1:A}[${2:l}]${3:++};
$1[${4:r+1}]${5:--};
endsnippet

snippet ww_algo_compress "compress" b
vector<${1:long long}> ${2:cvt} = ${3:S};
sort($2.begin(), $2.end());
$2.erase(unique($2.begin(), $2.end()), $2.end());
for (auto &v : $3) v = lower_bound($2.begin(), $2.end(), v) - $2.begin();
int ${4:cnt} = $2.size();
endsnippet

# =========================================================
# UnionFind
# =========================================================
snippet ww_struct_uf "union find" b
struct UnionFind {
  private:
	int N;
	vector<int> par;

  public:
	UnionFind(int N) : N(N), par(N) {
		iota(par.begin(), par.end(), 0);
	}
	int getRoot(const int &i) {
		return par[i] == i ? i : par[i] = getRoot(par[i]);
	}
	void unite(int x, int y) {
		int rx = getRoot(x), ry = getRoot(y);
		if (rx == ry) return;
		par[rx] = ry;
	}
	bool isSameRoot(int x, int y) {
		return getRoot(x) == getRoot(y);
	}
	bool isRoot(int i) {
		return getRoot(i) == i;
	}
	int getRootCnt() {
		int cnt = 0;
		for (int i = 0; i < N; i++) {
			if (isRoot(i)) cnt++;
		}
		return cnt;
	}
};
endsnippet

# =========================================================
# Struct RxQ Monoid
# =========================================================
snippet ww_struct_RxQ_min "RxQ min" b
template <class T> constexpr T inf = 0;
template <> constexpr int inf<int> = 1001001001;
template <> constexpr long long inf<long long> = 1001001001001001001ll;
template <typename T> struct RxQmin {
	using value_type = T;
	static constexpr T e = inf<T>;
	static constexpr T ope(const T &x, const T &y) noexcept {
		return min(x, y);
	}
};
endsnippet

snippet ww_struct_RxQ_max "RxQ max" b
template <class T> constexpr T inf = 0;
template <> constexpr int inf<int> = 1001001001;
template <> constexpr long long inf<long long> = 1001001001001001001ll;
template <typename T> struct RxQmax {
	using value_type = T;
	static constexpr T e = -inf<T>;
	static constexpr T ope(const T &x, const T &y) noexcept {
		return max(x, y);
	}
};
endsnippet

snippet ww_struct_RxQ_sum "RxQ sum" b
template <typename T> struct RxQsum {
	using value_type = T;
	static constexpr T e = 0;
	static constexpr T ope(const T &x, const T &y) noexcept {
		return x + y;
	}
};
endsnippet

snippet ww_struct_RxQ_prod "RxQ prod" b
template <typename T> struct RxQprod {
	using value_type = T;
	static constexpr T e = 1;
	static constexpr T ope(const T &x, const T &y) noexcept {
		return x * y;
	}
};
endsnippet

snippet ww_struct_RxQ_gcd "RxQ gcd" b
template <typename T> struct RxQgcd {
	using value_type = T;
	static constexpr T e = 1;
	static constexpr T ope(const T &x, const T &y) noexcept {
		return gcd(x, y);
	}
};
endsnippet

# =========================================================
# Segment Tree
# =========================================================
snippet ww_struct_segment_tree "segment tree" b
template <class M> struct SegTree {
	using T = typename M::value_type;

  private:
	int N;
	vector<T> node;
	void update(const int &i) {
		node[i] = M::ope(node[i << 1 | 0], node[i << 1 | 1]);
	}

  public:
	SegTree(int n) : N(n), node(n << 1, M::e){};
	SegTree(int n, const vector<T> &a) : N(n), node(n << 1, M::e) {
		for (int i = 0; i < N; i++) node[i + N] = a[i];
		for (int i = N - 1; i >= 0; i--) update(i);
	}
	T operator[](const int &i) {
		return node[i + N];
	}
	void set(int i, const T &x) {
		node[i += N] = x;
		while (i >>= 1) update(i);
	}
	T get(int l, int r) {
		T L = M::e, R = M::e;
		for (l += N, r += N; l < r; l >>= 1, r >>= 1) {
			if (l & 1) L = M::ope(L, node[l++]);
			if (r & 1) R = M::ope(node[--r], R);
		}
		return M::ope(L, R);
	}
	T top() {
		return node[1];
	}
};
endsnippet

snippet ww_struct_segment_tree_inline "seg" b
${1:int} e = ${2:INF};
vector<$1> seg(${3:N} << 1, e);
endsnippet

snippet ww_struct_segment_tree_build "seg build" b
for (int i = 0; i < ${1:N}; i++) {
	seg[i + $1] = ${2:A}[i];
}
for (int i = $1 - 1; i >= 0; i--) {
	${5:bind}
}
endsnippet

snippet ww_struct_segment_tree_query "seg query" b
auto vl = e, vr = e;
int ans = 0;
for (${1:int} ${2:l} ${3:+= N}, ${4:r} ${5:+= N}; $2 < $4; $2 >>= 1, $4 >>= 1) {
	if ($2 & 1) {
		${6:pick}
	}
	if ($4 & 1) {
		${7:pick}
	}
}
endsnippet

snippet ww_struct_segment_tree_update "seg upd" b
int ${1:leaf} = ${2:i + N};
seg[$1] = ${3:x};
while ($1 >>= 1) {
	${4:bind}
}
endsnippet

# TODO XXX FIXME add upper lower bound
# TODO XXX FIXME add imos lazy update

snippet ww_struct_segment_tree_bind_RMQ "seg min max gcd" b
seg[${1:i}] = ${2:min max gcd}(seg[$1 << 1 | 0], seg[$1 << 1 | 1]);
endsnippet

snippet ww_struct_segment_tree_bind_Ope "seg + *" b
seg[${1:i}] = seg[$1 << 1 | 0] ${2:+ *} seg[$1 << 1 | 1];
endsnippet

snippet ww_struct_segment_tree_pick_RMQ "seg min max gcd" b
${1:vl vr} = ${3:min max gcd}($1, seg[${2:l++ --r}]);
endsnippet

snippet ww_struct_segment_tree_pick_Ope "seg + *" b
${1:vl vr} ${3:+ *}= seg[${2:l++ --r}];
endsnippet

snippet ww_struct_segment_tree_RCQ_struct "seg RCQ" b
template <typename T> struct SegRCQ {
  private:
	int N;
	vector<unordered_map<int, int>> node;
	void bind(const int &i) {
		for (auto v : node[i << 1 | 0]) node[i][v.first] += v.second;
		for (auto v : node[i << 1 | 1]) node[i][v.first] += v.second;
	}

  public:
	SegRCQ(int n) : N(n), node(n << 1){};
	SegRCQ(int n, const vector<T> &a) : N(n), node(n << 1) {
		for (int i = 0; i < N; i++) node[i + N][a[i]] = 1;
		for (int i = N - 1; i >= 0; i--) bind(i);
	}
	unordered_map<int, int> operator[](int i) {
		return node[i + N];
	}
	void set(int i, T x) {
		node[i += N] = x;
		while (i >>= 1) bind(i);
	}
	T get(int l, int r, int x) {
		T vl = 0, vr = 0;
		for (l += N, r += N; l < r; l >>= 1, r >>= 1) {
			if (l & 1) {
				if (node[l].count(x)) vl += node[l][x];
				l++;
			}
			if (r & 1) {
				--r;
				if (node[r].count(x)) vl += node[r][x];
			}
		}
		return vl + vr;
	}
	T top() {
		return node[1];
	}
};
endsnippet

# =========================================================
# Fenwick Tree
# =========================================================
snippet ww_struct_fenwick_tree "fenwick tree" b
template <typename M> struct FwkTree {
	using T = typename M::value_type;

  private:
	int N;
	vector<T> node;
	void bind(T &x, const T &y) {
		x = M::ope(x, y);
	}

  public:
	FwkTree(int n) : N(n), node(n + 1, M::e){};
	FwkTree(int n, const vector<T> &a) : N(n), node(n + 1, M::e) {
		for (int i = 1; i <= N; i++) {
			bind(node[i], a[i - 1]);
			int f = i + (i & -i);
			if (f <= N) bind(node[f], node[i]);
		}
	}
	void act(const int &i, const T &x) {
		for (int f = i + 1; f <= N; f += f & -f) bind(node[f], x);
	}
	T get(const int &r) {
		T ans = M::e;
		for (int f = r + 1; f; f -= f & -f) bind(ans, node[f]);
		return ans;
	}
};
endsnippet

snippet ww_struct_fenwick_tree_inline "fenwick" b
vector<${1:int}> fwk(${2:N} + 1, ${3:0});
endsnippet

snippet ww_struct_fenwick_tree_build "fenwick build" b
for (int i = 1; i < ${1:N}; i++) {
	fwk[i] += ${2:A}[i - 1];
	int f = i + (i & -i);
	if (l <= $1) {
		fwk[f] += fwk[i];
	}
}
endsnippet

snippet ww_struct_fenwick_tree_query "fenwick query" b
int ${1:ans} = ${2:0};
for (int ${3:f} = ${4:idx_1}; $3; $3 -= $3 & -$3) {
	$1 ${5:+}= fwk[$3];
}
endsnippet

snippet ww_struct_fenwick_tree_update "fenwick update" b
for (int ${1:f} = ${2:idx_1}; $1 <= ${3:N}; $1 += $1 & -$1) {
	fwk[$1] ${4:++ +=some};
}
endsnippet
