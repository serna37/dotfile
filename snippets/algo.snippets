# =========================================================
# const
# =========================================================
snippet const_inf "infinity" b
template <class T> constexpr T inf = 0;
template <> constexpr int inf<int> = 1e9;
template <> constexpr long long inf<long long> = 1e18;
endsnippet
snippet const_inf_i "infinity int" b
constexpr int INF = 1e9;
endsnippet
snippet const_inf_l "infinity long long" b
constexpr long long INF = 1e18;
endsnippet
snippet const_MOD_998244353 "mod" b
constexpr long long MOD = 998244353;
endsnippet
snippet const_MOD_100000007 "mod" b
constexpr long long MOD = 1000000007;
endsnippet
snippet const_grid_dydx4 "grid connector" b
const vector<int> dx = {0, 1, 0, -1};
const vector<int> dy = {1, 0, -1, 0};
endsnippet
snippet const_grid_dydx8 "grid connector" b
const vector<int> dx = {0, 1, 0, -1, 1, -1, 1, -1};
const vector<int> dy = {1, 0, -1, 0, 1, 1, -1, -1};
endsnippet
snippet const_PI "PI" b
const double PI = acos(-1);
endsnippet

# =========================================================
# input
# =========================================================
snippet in_1 "in 1" b
${1:int} ${2:N};
cin >> $2;
endsnippet
snippet in_1_vec "in 1 + vec" b
${1:int} ${2:N};
cin >> $2;
vector<${3:int}> ${4:A}($2);
for (int i = 0; i < $2; i++) cin >> $4[i];
endsnippet
snippet in_2 "in 2" b
${1:int} ${2:N}, ${3:M};
cin >> $2 >> $3;
endsnippet
snippet in_3 "in 3" b
${1:int} ${2:N}, ${3:M}, ${4:K};
cin >> $2 >> $3 >> $4;
endsnippet
snippet in_4 "in 4" b
${1:int} ${2:N}, ${3:M}, ${4:K}, ${5:S};
cin >> $2 >> $3 >> $4 >> $5;
endsnippet
snippet vec_in_1 "vec in 1" b
vector<${1:int}> ${2:A}(${3:N});
for (int i = 0; i < $3; i++) cin >> $2[i];
endsnippet
snippet vec_in_2 "vec in 2" b
vector<${1:int}> ${2:A}(${4:N}), ${3:B}($4);
for (int i = 0; i < $4; i++) cin >> $2[i] >> $3[i];
endsnippet
snippet vec_in_3 "vec in 3" b
vector<${1:int}> ${2:A}(${5:N}), ${3:B}($5), ${4:C}($5);
for (int i = 0; i < $5; i++) cin >> $2[i] >> $3[i] >> $4[i];
endsnippet
snippet grid_in "grid in" b
vector<vector<${1:char}>> ${2:G}(${3:H}, vector<$1>(${4:W}));
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		cin >> $2[i][j];
	}
}
endsnippet
snippet graph_in "graph in" b
vector<vector<${1:int}>> ${2:G}(${3:N});
for (int i = 0; i < ${4:M}; i++) {
	$1 ${5:A}, ${6:B};
	cin >> $5 >> $6;
	$5--, $6--;
	$2[$5].push_back($6);
	$2[$6].push_back($5);
}
endsnippet
snippet graph_cost_in "graph cost in" b
Graph<${1:long long}> ${2:G}(${3:N});
for (int i = 0; i < ${4:M}; i++) {
	int from, to;
	cin >> from >> to;
	from--, to--;
	$1 cost;
	cin >> cost;
	$2.add(from, to);
	$2.add(to, from);
	$2.add(from, to, cost, i);
	$2.add(to, from, cost, i);
}
endsnippet
snippet edges_cin "edges in" b
Graph<${1:long long}> ${2:G}(${3:N});
vector<Edge<$1>> edges;
for (int i = 0; i < ${4:M}; i++) {
	int from, to;
	cin >> from >> to;
	from--, to--;
	$1 cost;
	cin >> cost;
	$2.add(from, to, cost, i);
	$2.add(to, from, cost, i);
	edges.push_back({from, to, cost, i});
}
endsnippet

# =========================================================
# output
# =========================================================
snippet cout "cout" b
cout << ${1:ans} << endl;
endsnippet
snippet cout_no_yes "yes no" b
cout << (${1:condition} ? "${2:Yes}" : "${3:No}") << endl;
endsnippet
snippet cout_vec "cout vector" b
for (int ${1:i} = 0; $1 < ${2:N}; $1++) {
	if ($1) cout << " ";
	cout << ${3:A}[$1];
}
cout << endl;
endsnippet
snippet cout_all "cout all" b
int i = 0;
for (auto &&v : ${1:st}) {
	if (i++) cout << " ";
	cout << v;
}
cout << endl;
endsnippet
snippet cout_grid "cout grid" b
for (int ${1:i} = 0; $1 < ${2:N}; $1++) {
	for (int ${3:j} = 0; $3 < ${4:M}; $3++) {
		if ($3) cout << " ";
		cout << ${5:G}[$1][$3];
	}
	cout << endl;
}
endsnippet
snippet cout_map "cout map" b
for (auto &&[k, v] : ${1:mp}) cout << "[" << k << "," << v << "] ";
cout << endl;
endsnippet
snippet cout_endl "endl" b
cout << endl;
endsnippet
snippet cout_fixed_setprecision "fixed setprecision" b
cout << fixed << setprecision(${1:20});
endsnippet

# =========================================================
# Algorithm reduce eval
# =========================================================
snippet algo_alma "allmatch" b
bool alma = true;
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	alma &= ${4};
}
endsnippet
snippet algo_anma "anymatch" b
bool anma = false;
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	anma |= ${4};
}
endsnippet
snippet algo_gcd_all "gcd all" b
${1:long long} ${2:GCD} = ${3:A}[0];
for (int i = 1; i < ${4:N}; i++) {
	$2 = gcd($2, $3[i]);
}
endsnippet
snippet algo_lcm_all "lcm all" b
${1:long long} ${2:LCM} = 1;
for (int i = 0; i < ${3:N}; i++) {
	$2 = lcm($2, ${4:A}[i]);
}
endsnippet

# =========================================================
# Algorithm Search
# =========================================================
snippet algo_permu_loop "next permutation" b
do {${2}} while (next_permutation(${1:A}.begin(), $1.end()));
endsnippet
snippet algo_bit_loop "bit loop" b
for (${1:long long} ${2:bit} = 0; $2 < (${3:1ll} << ${4:N}); $2++) {
	${5:long long} tmp = 0;
	for (int k = 0; k < $4; k++) {
		// k番目を使うか
		if ($2 & ($3 << k)) {
			tmp |= ${6:A}[k];
		}
	}
}
endsnippet
snippet algo_bit_loop_2 "bit loop" b
for (int bit = 0; bit < (1 << ${1:H}); bit++) {
	for (int bit2 = 0; bit2 < (1 << ${2:W}); bit2++) {
		vector<int> ${3:h}, ${4:w};
		for (int k = 0; k < $1; k++) {
			// k番目を使うか
			if (bit & (1 << k)) $3.push_back(k);
		}
		for (int k = 0; k < $2; k++) {
			// k番目を使うか
			if (bit2 & (1 << k)) $4.push_back(k);
		}
	}
}
endsnippet
snippet algo_bit_n_order "bit N" b
// ${1:N}桁の${2:K}進数
vector<int> bit($1, 0);
while (1) {
	for (int i = 0; i < $1; i++) {
		int tmp = bit[i]; // i桁目の数字（$2進法）
	}
	// インクリメント
	int order = $1 - 1, stop = 0;
	while (1) {
		bit[order]++;
		if (bit[order] < $2) break; // くりあげ終了
		if (order == 0) { // 最大桁が溢れた
			stop = 1;
			break; 
		}
		bit[order--] = 0; // 繰り上げて次の桁
	}
	if (stop) break;
}
endsnippet
# TODO bit演算系としてまとめ直したい
snippet algo_bit_on_all_pattern "bit on all pattern" b
for (long long i = ${1:N}; i > 0; i = (i - 1) & $1) {
	cout << $1 - i << endl;
}
cout << $1 << endl;
endsnippet
snippet algo_syakutori "syakutori" b
// lを固定
// 連続和がKまでrを増やす
// whileがfalseになるので、区間の個数はr-l個
// lを増やして繰り返す
for (int l = 0, r = 0, ${1:sum} = 0; l < ${2:N}; $1 -= ${3:A}[l++]) {
	while (r < $2 and $1 + $3[r] <= ${4:K}) $1 += $3[r++];
	${5:ans} += r - l;
}
endsnippet

# =========================================================
# Algorithm BinarySearch
# =========================================================
snippet algo_bisearch "bisearch" b
auto ${1:test} = [&](${2:long long} x) -> bool {
	${3:return x >= K}
};
$2 ${4:L} = 0, ${5:R} = 1, ${6:MID} = 0;
while (!$1($5)) $5 <<= 1; // 指数探索
while ($5 - $4 > 1) ($1($6 = $4 + ($5 - $4) / 2) ? $5 : $4) = $6;
cout << $5 << endl;
endsnippet
snippet algo_bi_ika_cnt "ika cnt" b
// 以下の個数 = より大きい最左のidx
${1:int} ${2:cnt} = upper_bound(${3:A}.begin(), $3.end(), ${4:x}) - $3.begin();
endsnippet
snippet algo_bi_sita_cnt "sita cnt" b
// より下の個数 = 以上最左のidx
${1:int} ${2:cnt} = lower_bound(${3:A}.begin(), $3.end(), ${4:x}) - $3.begin();
endsnippet
snippet algo_bi_izyou_cnt "izyou cnt" b
// 以上の個数
${1:int} ${2:cnt} = ${3:A}.end() - lower_bound($3.begin(), $3.end(), ${4:x});
endsnippet
snippet algo_bi_ue_cnt "ue cnt" b
// より大きい個数
${1:int} ${2:cnt} = ${3:A}.end() - upper_bound($3.begin(), $3.end(), ${4:x});
endsnippet
snippet algo_bi_ika_max "0, lim]" b
// 以下の最右
auto itr = ${1:st}.upper_bound(${2:A});
if (itr == $1.begin()) continue;
--itr;
endsnippet
snippet algo_bi_sita_max "0, lim)" b
// より下の最右
auto itr = ${1:st}.lower_bound(${2:A});
if (itr == $1.begin()) continue;
--itr;
endsnippet
snippet algo_bi_izyou_min "[lim, N" b
// 以上の最左
auto itr = ${1:st}.lower_bound(${2:A});
if (itr == $1.end()) continue;
endsnippet
snippet algo_bi_ue_min "(lim, N" b
// より大きい最左
auto itr = ${1:st}.upper_bound(${2:A});
if (itr == $1.end()) continue;
endsnippet

# =========================================================
# Algorithm Range
# =========================================================
snippet algo_zeta "ruisekiwa" b
vector<${1:long long}> ${2:S}(${3:N} + 1);
for (int i = 0; i < $3; i++) {
	$2[i + 1] = $2[i] + ${4:A}[i];
} // S_i = a_0 + ... + a_i-1 →
endsnippet
snippet algo_zeta_rev "ruisekiwa reverse" b
vector<${1:long long}> ${2:R}(${3:N} + 1);
for (int i = $3 - 1; i >= 0; i--) {
	$2[i] = $2[i + 1] + ${4:A}[i];
} // S_i = ← a_n-i + ... + a_n-1
endsnippet
snippet algo_zeta_2D "2d ruisekiwa" b
// 2次元ゼータ変換
vector<vector<${1:long long}>> ${2:S}(${3:H} + 1, vector<$1>(${4:W} + 1));
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		$2[i + 1][j + 1] = $2[i + 1][j] + ${5:A}[i][j];
	}
}
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		$2[i + 1][j + 1] += $2[i][j + 1];
	}
}
endsnippet
snippet algo_moebius "diff" b
vector<${1:int}> ${2:D}(${3:N-1});
for (int i = 0; i < $3; i++) {
	$2[i] = ${4:A}[i + 1] - $4[i];
}
endsnippet
snippet algo_imos "imos" b
// imos
${1:A}[${2:l}]${3:++};
$1[${4:r+1}]${5:--};
endsnippet

# =========================================================
# Algorithm seq
# =========================================================
snippet algo_seq_inv "seq inv" b
auto [comp, cvt] = zip(${1:A});
// $1の転頭数
${2:int} ${3:inv} = 0;
FwkTree<Madd<int>> ${4:fwk}(cvt.size());
for (int i = 0; i < ${5:N}; i++) {
	$3 += $4.top() - $4.get(comp[i]);
	$4.act(comp[i], 1);
}
endsnippet
snippet algo_merge_set "merge set" b
// ${1:A}を${2:B}にマージ
if ($1.size() > $2.size()) swap($1, $2);
for (auto &&v : $1) $2.insert(v);
$1.clear();
endsnippet
snippet algo_merge_vec "merge vec" b
// ${1:A}を${2:B}にマージ
if ($1.size() > $2.size()) swap($1, $2);
for (auto &&v : $1) $2.push_back(v);
$1.clear();
endsnippet
snippet algo_swap_left "swap left" b
// ${1:A} < ${2:B} を保証する
if ($1 > $2) swap($1, $2);
endsnippet

# =========================================================
# Algorithm BFS
# =========================================================
snippet algo_bfs "bfs" b
// 単一始点BFS
queue<int> q;
vector<int> dis(${1:N}, -1);
q.push(${2:0});
dis[$2] = 0;
while (!q.empty()) {
	int v = q.front();
	q.pop();
	for (auto &&nv : ${3:G}[v]) {
		if (dis[nv] == -1) {
			dis[nv] = dis[v] + 1;
			q.push(nv);
		}
	}
}
endsnippet
snippet algo_bfs_multi_start "bfs multi start" b
// 複数始点BFS
queue<int> q;
vector<int> dis(${1:N}, -1);
for (int i = 0; i < ${2:K}; i++) {
	q.push(${3:C[i]});
	dis[$3] = 0;
}
while (!q.empty()) {
	int v = q.front();
	q.pop();
	for (auto &&nv : ${4:G}[v]) {
		if (dis[nv] == -1) {
			dis[nv] = dis[v] + 1;
			q.push(nv);
		}
	}
}
endsnippet
snippet algo_bfs_grid "bfs grid" b
// 単一始点グリッドBFS
queue<pair<int, int>> q;
q.push({${1:sy}, ${2:sx}});
vector<vector<int>> dis(${3:H}, vector<int>(${4:W}, -1));
dis[$1][$2] = 0;
while (!q.empty()) {
	auto [py, px] = q.front();
	q.pop();
	for (int i = 0; i < 4; i++) {
		int y = py + dy[i], x = px + dx[i];
		if (y < 0 or x < 0 or $3 <= y or $4 <= x) continue;
		if (dis[y][x] == -1 and cango(${5:G}[y][x])) {
			dis[y][x] = dis[py][px] + 1;
			q.push({y, x});
		}
	}
}
endsnippet
snippet algo_grid_dydx "dydx" b
for (int ${1:k} = 0; $1 < ${2:4}; $1++) {
	int y = ${3:i} + dy[$1], x = ${4:j} + dx[$1];
	if (y < 0 or x < 0 or ${5:row} <= y or ${6:col} <= x) continue;
	${7}
}
endsnippet
snippet algo_grid_filter "bfs grid filter" b
if (${1:y} < 0 or ${2:x} < 0 or ${3:row} <= $1 or ${4:col} <= $2) continue;
endsnippet
snippet algo_grid_cango "grid cango" b
auto cango = [](const char &a) -> bool {
	string white = "${1:.SG}";
	return white.find(a) != string::npos;
};
endsnippet
snippet algo_toguro "toguro" b
int y = 0, x = 0, d = 0;
for
y += dy[d], x += dx[d];
if (y < 0 or x < 0 or ${1:row} <= y or ${2:col} <= x or G[y][x] != -1) {
	y -= dy[d], x -= dx[d]; // やっぱ戻って
	d++, d %= 4; // 方向変えて
	y += dy[d], x += dx[d]; // 進直す
}
endsnippet
snippet algo_bingo "bingo" b
vector<int> cx(${1:N}); // クロス1
iota(cx.begin(), cx.end(), 0);
vector<int> cy = cx; // クロス2
reverse(cy.begin(), cy.end());
bool c1 = true, c2 = true;
${2:int} check_val = ${3:-1};
for (int i = 0; i < $1; i++) {
	c1 &= ${4:A}[i][cx[i]] == check_val; // 左上から右下
	c2 &= $4[i][cy[i]] == check_val; // 右上から左下
	bool alma = true, alma2 = true;
	for (int j = 0; j < $1; j++) {
		alma &= $4[i][j] == check_val; // 行内でallmatch
		alma2 &= $4[j][i] == check_val; // 列内でallmatch
	}
	if (alma or alma2) {
		cout << "TODO row col allmatch" << endl;
	}
}
if (c1 or c2) {
	cout << "TODO cross allmatch" << endl;
}
endsnippet

# =========================================================
# Algorithm DFS
# =========================================================
snippet algo_dfs "dfs" b
// DFS
vector<bool> seen(${1:N}, false);
auto dfs = [&](auto &f, int v) -> void {
	// 行きがけ
	seen[v] = true;
	for (auto &&nv : ${2:G}[v]) {
		if (seen[nv]) continue;
		f(f, nv);
	}
	// 帰りがけ
};
dfs(dfs, ${3:0});
endsnippet
# TODO これいらんかなぁ？
snippet algo_dfs_tree "dfs" b
// DFS
vector<int> depth(N);
auto dfs = [&](auto &f, int v, int p, int d) -> void {
	// 行きがけ
	depth[v] = d;
	for (int nv : ${1:G}[v]) {
		if (nv == p) continue;
		f(f, nv, v, d + 1);
	}
	// 帰りがけ
};
dfs(dfs, ${2:root}, -1, 0);
endsnippet

# =========================================================
# Algorithm DP
# =========================================================
snippet algo_dp_ch_transition "dp" b
dp[${1:i} + 1][${2:j to}] ${3:=  +=} dp[$1][${4:j from}];
endsnippet
snippet algo_dp_ch_knapsack "knapsack" b
dp[${1:i} + 1][${2:j  j+tran}] = 
	${3:min}(dp[$1 + 1][$2], dp[$1][${4:j  j-tran}] + ${5:cost});
endsnippet

# TODO 遷移式メインに修正中
snippet algo_dp_frog "dp frog" b
vector<${1:int}> dp(${2:N} + 1, ${3:inf<int>});
dp[${4:0}] = ${5:0};
for (int i = 0; i <= $2; i++) {
	for (int j = 0; j < ${6:M}; j++) {
		${7}
	}
}
cout << dp[$2] << endl;
endsnippet
snippet algo_dp_vacation "dp vacation" b
vector<vector<${1:int}>> dp(${2:N} + 1, vector<$1>(${3:3}, 0));
for (int i = 0; i < $2; i++) {
	for (int j = 0; j < $3; j++) {
		for (int k = 0; k < $3; k++) {
			if (j == k) continue;
			dp[i + 1][j] = max(dp[i + 1][j], dp[i][k] + ${4:A}[k][i]);
		}
	}
}
$1 ans = 0;
for (int i = 0; i < $3; i++) {
	ans = max(ans, dp[$2][i]);
}
cout << ans << endl;
endsnippet
snippet algo_dp_partial "dp partial" b
vector<vector<bool>> dp(${1:N} + 1, vector<bool>(${2:M} + 1, false));
dp[0][0] = true;
for (int i = 0; i < $1; i++) {
	for (int j = 0; j <= $2; j++) {
		if (!dp[i][j]) continue;
		${3:dp[i+1][j] = true;}
	}
}
cout << (dp[$1][$2] ? "Yes" : "No") << endl;
endsnippet
snippet algo_dp_knapsack "dp knapsack" b
vector<vector<${1:int}>> dp(${2:N} + 1, vector<$1>(${3:W} + 1, 0));
for (int i = 0; i < $2; i++) {
	for (int j = 0; j <= $3; j++) {
		dp[i + 1][j] = dp[i][j];
		if (${4:w}[i] <= j) {
			dp[i + 1][j] = max(dp[i + 1][j], dp[i][j - $4[i]] + ${5:v}[i]);
			dp[i + 1][j] = max(dp[i + 1][j], dp[i + 1][j - $4[i]] + $5[i]);
		}
	}
}
cout << dp[$2][$3] << endl;
endsnippet
snippet algo_dp_knapsack_alt "dp knapsack alt" b
int ${1:V} = ${2:1e5};
vector<vector<${3:int}>> dp(${4:N} + 1, vector<$3>($1 + 1, inf<$3>));
dp[0][0] = 0;
for (int i = 0; i < $4; i++) {
	for (int j = 0; j <= $1; j++) {
		dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);
		if (v[i] <= j) {
			dp[i + 1][j] = min(dp[i + 1][j], dp[i][j - ${5:v}[i]] + ${6:w}[i]);
		}
	}
}
$3 ans = 0;
for (int i = 0; i <= $1; i++) {
	if (dp[$4][i] <= ${7:W}) {
		ans = max(ans, i);
	}
}
cout << ans << endl;
endsnippet
snippet algo_dp_transition "dp transition" b
vector<vector<${1:long long}>> dp(${2:N} + 1, vector<$1>(${3:M} + 1, 0));
dp[0][0] = 1;
for (int i = 0; i < $2; i++) {
	for (int j = 0; j <= $3; j++) {
		dp[i + 1][j] += dp[i][j];
		if (${4:j < 8 and S[i] == M[j]}) {
			dp[i + 1][j + 1] += dp[i][j];
		}
	}
}
cout << dp[$2][$3] << endl;
endsnippet
snippet algo_dp_lcs "dp lcs" b
int ${3:s} = ${1:S}.size(), ${4:t} = ${2:T}.size();
vector<vector<int>> dp($3 + 1, vector<int>($4 + 1, 0));
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		dp[i + 1][j + 1] = max(
			{dp[i][j + 1], dp[i + 1][j], dp[i][j] + ($1[i] == $2[j])});
	}
}
cout << dp[$3][$4] << endl;
endsnippet
snippet algo_dp_lis "dp lis" b
// WIP
endsnippet
snippet algo_dp_order "dp order" b
// WIP
endsnippet
snippet algo_dp_range "dp range" b
// WIP
endsnippet
snippet algo_dp_seg "dp seg" b
SegTree<Mmin<${1:long long}>> dp(${2:N+1});
dp.set(0, 0);
for (int i = 0; i < ${3:M}; i++) {
	auto [r, l, c] = T[i];
	$1 asis = dp[r];
	$1 tobe = dp.get(l, r) + c;
	dp.set(r, min(asis, tobe));
}
cout << dp[N] << endl;
endsnippet
snippet algo_dp_bit "dp bit" b
// WIP
endsnippet
snippet algo_dp_tree "dp tree" b
vector<${1:long long}> dp(${2:N}, ${3:0});
auto dfs = [&](auto &f, int v, int par = -1) -> void {
	if (${4:tree}[v].size() == 1) {
		dp[v] = 0;
		return;
	}
	$1 tmp = 0;
	for (auto &&[from, to, cost, id] : $4[v]) {
		if (to == par) continue;
		f(f, to, from);
		tmp = ${5:max}(tmp, dp[to] + cost);
	}
	dp[v] = tmp;
};
dfs(dfs, N);
cout << dp[N - 1] << endl;
endsnippet
snippet algo_dp_rerooting "dp rerooting" b
// WIP
endsnippet

# =========================================================
# Meaningful Mean
# =========================================================
snippet algo_meaningful_mean "meaningful mean" b
int N, K;
cin >> N >> K;
vector<long long> a(N), S(N + 1);
for (int i = 0; i < N; i++) cin >> a[i];
for (int i = 0; i < N; i++) S[i + 1] = S[i] + a[i] - K;
vector<long long> cvt = S;
sort(cvt.begin(), cvt.end());
cvt.erase(unique(cvt.begin(), cvt.end()), cvt.end());
for (auto &v : S) v = lower_bound(cvt.begin(), cvt.end(), v) - cvt.begin();
long long cnt = cvt.size(), ans = 0;
vector<int> fwk(cnt + 1, 0);
for (int i = 0; i < N + 1; i++) {
	for (int f = S[i] + 1; f; f -= f & -f) ans += fwk[f];
	for (int f = S[i] + 1; f <= cnt; f += f & -f) fwk[f]++;
}
cout << ans << endl;
endsnippet
