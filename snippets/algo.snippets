# =========================================================
# Algorithm Search
# =========================================================
snippet ww_algo_alma "allmatch" b
bool alma = true;
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	alma &= ${4};
}
endsnippet
snippet ww_algo_anma "anymatch" b
bool anma = false;
for (int ${1:i} = ${2:0}; $1 <${3:N}; $1++) {
	anma |= ${4};
}
endsnippet
snippet ww_algo_permu_loop "next permutation" b
do {${2}} while (next_permutation(${1:A}.begin(), $1.end()));
endsnippet
snippet ww_algo_bit_loop "bit loop" b
for (${1:long long} ${2:bit} = 0; $2 < (${3:1ll} << ${4:N}); $2++) {
	${5:long long} tmp = 0;
	for (int k = 0; k < $4; k++) {
		if ($2 & ($3 << k)) {
			tmp |= ${6:A}[k];
		}
	}
}
endsnippet
snippet ww_algo_bit_loop_2 "bit loop" b
for (int bit = 0; bit < (1 << ${1:H}); bit++) {
	for (int bit2 = 0; bit2 < (1 << ${2:W}); bit2++) {
		vector<int> ${3:h}, ${4:w};
		for (int k = 0; k < $1; k++) {
			if (bit & (1 << k)) $3.push_back(k);
		}
		for (int k = 0; k < $2; k++) {
			if (bit2 & (1 << k)) $4.push_back(k);
		}
	}
}
endsnippet
snippet ww_algo_bit_on_all_pattern "bit on all pattern" b
for (long long i = ${1:N}; i > 0; i = (i - 1) & $1) {
	cout << $1 - i << endl;
}
cout << $1 << endl;
endsnippet
snippet ww_algo_syakutori "syakutori" b
for (int l = 0, r = 0, ${1:sum} = 0; l < ${2:N}; $1 -= ${3:A}[l++]) {
	while (r < $2 and $1 + $3[r] <= ${4:K}) $1 += $3[r++];
	${5:ans} += r - l;
}
endsnippet

# =========================================================
# Algorithm BinarySearch
# =========================================================
snippet ww_algo_bisearch_ika_max "0, lim]" b
auto itr = st.upper_bound(${1:A});
if (itr == st.begin()) continue;
int a = *--itr;
endsnippet
snippet ww_algo_bisearch_sita_max "0, lim)" b
auto itr = st.lower_bound(${1:A});
if (itr == st.begin()) continue;
int a = *--itr;
endsnippet
snippet ww_algo_bisearch_izyou_min "[lim, N" b
auto itr = st.end() - st.lower_bound(${1:A});
int cnt = *itr;
endsnippet
snippet ww_algo_bisearch_ue_min "(lim, N" b
auto itr = st.end() - st.upper_bound(${1:A});
int cnt = *itr;
endsnippet

# =========================================================
# Algorithm Range
# =========================================================
snippet ww_algo_zeta "ruisekiwa" b
vector<${1:long long}> ${2:S}(${3:N} + 1);
for (int i = 0; i < $3; i++) {
	$2[i + 1] = $2[i] + ${4:A}[i];
}
endsnippet
snippet ww_algo_zeta_rev "ruisekiwa reverse" b
vector<${1:long long}> ${2:R}(${3:N} + 1);
for (int i = $3 - 1; i >= 0; i--) {
	$2[i] = $2[i + 1] + ${4:A}[i];
}
endsnippet
snippet ww_algo_zeta_2D "2d ruisekiwa" b
vector<vector<${1:long long}>> ${2:S}(${3:H} + 1, vector<$1>(${4:W} + 1));
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		$2[i + 1][j + 1] = $2[i + 1][j] + ${5:A}[i][j];
	}
}
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		$2[i + 1][j + 1] += $2[i][j + 1];
	}
}
endsnippet
snippet ww_algo_moebius "diff" b
vector<${1:int}> ${2:D}(${3:N-1});
for (int i = 0; i < $3; i++) {
	$2[i] = ${4:A}[i + 1] - $4[i];
}
endsnippet
snippet ww_algo_imos "imos" b
${1:A}[${2:l}]${3:++};
$1[${4:r+1}]${5:--};
endsnippet

snippet ww_algo_seq_inv "seq inv" b
auto [comp, cvt] = zip(${1:A});
${2:int} ${3:ans} = 0;
FwkTree<Madd<int>> ${4:fwk}(cvt.size());
for (int i = 0; i < ${5:N}; i++) {
	$3 += $4.top() - $4.get(comp[i]);
	$4.act(comp[i], 1);
}
endsnippet

# =========================================================
# Algorithm Graph
# =========================================================
snippet ww_algo_bfs_graph "bfs graph" b
queue<int> q;
q.push(${1:0});
vector<int> dis(${2:N}, -1);
dis[$1] = 0;
while (!q.empty()) {
	int v = q.front();
	q.pop();
	for (int nv : ${3:G}[v]) {
		if (dis[nv] == -1) {
			dis[nv] = dis[v] + 1;
			q.push(nv);
		}
	}
}
endsnippet
snippet ww_algo_bfs_grid "bfs grid" b
queue<pair<int, int>> q;
q.push({${1:sy}, ${2:sx}});
vector<vector<int>> dis(${3:H}, vector<int>(${4:W}, -1));
dis[$1][$2] = 0;
while (!q.empty()) {
	int py = q.front().first;
	int px = q.front().second;
	q.pop();
	for (int i = 0; i < 4; i++) {
		int y = py + dy[i];
		int x = px + dx[i];
		if (y < 0 or x < 0 or $3 <= y or $4 <= x) continue;
		if (dis[y][x] == -1 and cango(${5:G}[y][x])) {
			dis[y][x] = dis[py][px] + 1;
			q.push({y, x});
		}
	}
}
endsnippet
snippet ww_algo_grid_dydx "dydx" b
for (int ${1:k} = 0; $1 < ${2:4}; $1++) {
	int y = ${3:i} + dy[$1];
	int x = ${4:j} + dx[$1];
	if (y < 0 or x < 0 or ${5:row} <= y or ${6:column} <= x) continue;
	${7}
}
endsnippet
snippet ww_algo_grid_filter "bfs grid filter" b
if (${1:y} < 0 or ${2:x} < 0 or ${3:row} <= $1 or ${4:column} <= $2) continue;
endsnippet
snippet ww_algo_grid_cango "grid cango" b
auto cango = [](const char &a) -> bool {
	string white = "${1:.SG}";
	return white.find(a) != string::npos;
};
endsnippet

# =========================================================
# call
# =========================================================
# graph
snippet dijk "dijk" b
auto [dis, route] = dijkstra<${1:long long}>(${2:G}, ${3:start});
endsnippet
snippet Bellman "BellmanFord" b
auto [dis, route] = BellmanFord<${1:long long}>(${2:G}, ${3:start});
endsnippet
snippet Warshall "WarshallFroyd" b
auto dis = WarshallFroyd<${1:long long}>(${2:G});
endsnippet
snippet route "route restore" b
vector<int> ${1:rt} = route_restore(route, ${2:goal});
endsnippet
snippet cycle "cycle detect" b
vector<Edge<${1:long long}>> res = cycle_detect(${2:G}, ${3:true});
endsnippet

# set
snippet uf "union find" bi
UnionFind uf(${1:N});
endsnippet

# monoid
snippet mono_min "Monoid min" bi
Mmin<${1:int}>
endsnippet
snippet mono_max "Monoid max" bi
Mmax<${1:int}>
endsnippet
snippet mono_add "Monoid add" bi
Madd<${1:int}>
endsnippet
snippet mono_mul "Monoid mul" bi
Mmul<${1:int}>
endsnippet
snippet mono_gcd "Monoid gcd" bi
Mgcd<${1:int}>
endsnippet
snippet mono_act_sum_add "Monoid Acted sum add" bi
MAsumadd<${1:int}>
endsnippet
snippet mono_act_min_add "Monoid Acted min add" bi
MAminadd<${1:int}>
endsnippet

# range
snippet fwk "fwk" bi
FwkTree<${1}> fwk(${2:N});
endsnippet
snippet seg "seg" bi
SegTree<${1}> seg(${2:N});
endsnippet
snippet lseg "lseg" bi
LazySegTree<${1}> lseg(${2:N});
endsnippet
snippet starry "starry" b
StarrySkyTree<${1:int}> sst(${2:N});
endsnippet

# seq
snippet zip "zip" b
auto [comp, cvt] = zip(${1:A});
endsnippet
