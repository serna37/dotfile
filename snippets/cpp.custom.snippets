#*cpp.custom.snippets*        Version 1.0
#==============================================================================
#CONTENTS                                                 *cpp.custom*
#
#    const ....................... |const|
#    define ...................... |def some var|
#    calculation ................. |calculation template|
#    util ........................ |utility|
#    input ....................... |std cin|
#    output ...................... |std cout|
#
#==============================================================================

# =========================================================
# const
# =========================================================
snippet PI "PI" b
const double PI = acos(-1);
endsnippet
snippet INF "infinity int" b
constexpr int INF = 1e9;
endsnippet
snippet INF_ll "infinity long long" b
constexpr long long INF = 1e18;
endsnippet
snippet MOD_998244353 "mod" b
constexpr long long MOD = 998244353;
endsnippet
snippet MOD_100000007 "mod" b
constexpr long long MOD = 1000000007;
endsnippet
snippet EPS "eps" b
constexpr long double EPS = ${1:1e-14};
endsnippet
snippet MAX "MAX int" b
constexpr int MAX = ${1:2e6};
endsnippet
snippet GRID_dydx4 "grid connector" b
// 下右上左
// DRUL
const vector<int> dx = {0, 1, 0, -1};
const vector<int> dy = {1, 0, -1, 0};
endsnippet
snippet GRID_dydx8 "grid connector" b
const vector<int> dx = {0, 1, 0, -1, 1, -1, 1, -1};
const vector<int> dy = {1, 0, -1, 0, 1, 1, -1, -1};
endsnippet

# =========================================================
# define
# =========================================================
snippet w "w separator" b
// =====================================
endsnippet
snippet a "ans" b
${1:int} ans = ${2:0};
endsnippet
snippet c "cnt" b
${1:int} cnt = ${2:0};
endsnippet
snippet t "tmp" b
${1:int} ${2:tmp} = ${3:0};
endsnippet
snippet ok "ok" b
bool ok = ${1:false};
endsnippet
snippet alma "alma" b
bool alma = true;
endsnippet
snippet anma "anma" b
bool anma = false;
endsnippet
snippet size "size" b
int ${1:N} = ${2:S}.size();
endsnippet
snippet size "size" i
(int)${1:S}.size()${2}
endsnippet
snippet minus_2 "minus" b
--${1:A}, --${2:B};
endsnippet
snippet saninf "ternary operator inf" i
( ${1:ans} == ${2:INF} ? ${3:-1} : $1 )
endsnippet

# =========================================================
# calculation
# =========================================================
snippet allmatch "allmatch" b
${1:alma} &= ${2};
endsnippet
snippet anymatch "anymatch" b
${1:anma} |= ${2};
endsnippet
snippet cnt_all "cnt all" b
map<int, int> mp;
for (auto &&v : ${1:A}) ++mp[v];
endsnippet
snippet sum_all "sum all" b
long long sum = 0;
for (auto &&v : ${1:A}) sum += v;
endsnippet
snippet gcd_all "gcd all" b
long long GCD = 0;
for (auto &&v : ${1:A}) GCD = gcd(GCD, v);
endsnippet
snippet lcm_all "lcm all" b
long long LCM = 1;
for (auto &&v : ${1:A}) LCM = lcm(LCM, v);
endsnippet
snippet cast_itoch "tochar" i
(char)(${1:v} + '0')
endsnippet
snippet cast_chtoi "toint" i
(int)(${1:v} - '0')
endsnippet
snippet mod "mod" i
${1:ans} %= ${2:MOD}
endsnippet
snippet range "M個分の和by累積和" i
${1:S}[${2:i} + ${3:M}] - $1[$2]
endsnippet
snippet nc2 "nC2" i
${1:(long long)} ${2:val} * ($2 - 1) / 2
endsnippet
snippet tousa "等差数列の和" i
${1:(long long)} (1 + ${2:n}) * $2 / 2
endsnippet
snippet ceil "ceil" i
(${1:A} + ${2:B} - 1) / $2
endsnippet
snippet ceil2 "ceil2" i
(${1:A} + 1) / 2
endsnippet
snippet odd "odd" i
${1:i} & 1
endsnippet
snippet even "even" i
${1:i} % 2 == 0
endsnippet
snippet pattern_4 "4パターン" b
for (int ${1:k} = 0; $1 < 4; ++$1) {
	if ($1 & 1) { // x o x o
	}
	if ($1 & 2) { // x x o o
	}
}
endsnippet

# =========================================================
# util
# =========================================================

# short logic
snippet util_ren_max "ren max" b
// 条件を満たす、最大コンボ数
int ${1:ren_max} = 0;
for (int ren = 0, ${2:i} = ${3:0}; $2 <${4:N}; ++$2) {
	ren = ( ${5:condition} ? ren + 1 : 0);
	$1 = max($1, ren);
}
endsnippet

# wrapper
snippet util_divceil "divceil" b
// 負の場合0側へ丸めない
auto divCeil = []<class T>(T a, T b) -> T {
	return a / b + (((a ^ b) > 0 and a % b != 0) ? 1 : 0);
};
endsnippet
snippet util_divfloor "divfloor" b
// 負の場合0側へ丸めない
auto divFloor = []<class T>(T a, T b) -> T {
	return a / b - (((a ^ b) < 0 and a % b != 0) ? 1 : 0);
};
endsnippet

# string
snippet util_string_islower "string islower" b
// bool値を返すようwrap
auto islow = [](char c) -> bool { return islower(c) != 0; };
endsnippet
snippet util_string_isupper "string isupper" b
// bool値を返すようwrap
auto isupp = [](char c) -> bool { return isupper(c) != 0; };
endsnippet
snippet util_string_lpad "string lpad" b
auto lpad = [](const string &S, int size, char ch) -> string {
	int N = S.size();
	if (N >= size) return S;
	return string(size - N, ch) + S;
};
endsnippet
snippet util_string_rpad "string rpad" b
auto rpad = [](const string &S, const int &size, const char &ch) -> string {
	int N = S.size();
	if (N >= size) return S;
	return S + string(size - N, ch);
};
endsnippet
snippet util_string_finds "string finds" b
// T中のS出現場所を全列挙
auto finds = [](const string &T, const string &S) -> vector<int> {
	vector<int> pos;
	auto p = T.find(S);
	while (p != string::npos) {
		pos.emplace_back(p);
		p = T.find(S, p + 1);
	}
	return pos;
};
endsnippet
snippet util_string_split "string split" b
// aaaAaaa.split(A) -> aaa, aaa    BBB.split(A) -> ""
auto split = [](const string &S, const char &sep) -> vector<string> {
	vector<string> res = {""};
	for (auto &&v : S) {
		if (v == sep) {
			res.emplace_back("");
		} else {
			res.back() += v;
		}
	}
	return res;
};
endsnippet
snippet util_string_split_multi "string split multi" b
// aaaABaaa.split(AB) -> aaa, aaa
auto split = [](const string &S, const string &seps) -> vector<string> {
	vector<string> res = {""};
	for (auto &&v : S) {
		if (count(seps.begin(), seps.end(), v)) {
			res.emplace_back("");
		} else {
			res.back() += v;
		}
	}
	return res;
};
endsnippet

# geo
snippet util_rad "rad" b
// 度数法 → 弧度法
auto rad = [](const double &d) -> double { return d * PI / 180; };
endsnippet
snippet util_deg "deg" b
// 弧度法 → 度数法
auto deg = [](const double &r) -> double { return r * 180 / PI; };
endsnippet
snippet util_geo_area_triangle "geo area triangle" b
auto area_triangle = []<class T>(T x1, T y1, T x2, T y2, T x3, T y3) -> double {
	return abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)) / 2.0;
};
endsnippet
snippet util_geo_area_square "geo area square" b
auto area_square = []<class T>(T x1, T y1, T x2, T y2, T x3, T y3, T x4, T y4) -> double {
	return hypot(x1 - x3, y1 - y3) * hypot(x2 - x4, y2 - y4) / 2.0;
};
endsnippet

# grid
snippet util_grid_around "grid around" b
// 周囲のマスへ訪問する
for (int k = 0; k < ${1:4}; ++k) {
	int y = i + dy[k], x = j + dx[k];
	${2}
}
endsnippet
snippet util_grid_go "grid go" b
// いまの点からずーーっと進む
int y = ${1:i}, x = ${2:j}; // 始点とする
// for
y += dy[${3:d}], x += dx[$3]; // マス移動する
endsnippet
snippet util_grid_filter "grid filter" b
// 領域外
if (${1:y} < 0 or ${2:x} < 0 or ${3:row} <= $1 or ${4:col} <= $2) ${5:continue};
endsnippet
snippet util_grid_cango "grid cango" b
// 進めるか判定する
auto cango = [](const char &a) -> bool {
	string whitelist = "${1:.SG}";
	return whitelist.find(a) != string::npos;
};
endsnippet
snippet util_grid_transpose "grid transpose" b
// $7の縦横を転置する
swap(${1:H}, ${2:W});
vector<vector<${3:char}>> ${4:_G}($1, vector<$3>($2));
for (int ${5:i} = 0; $5 < $1; ++$5) {
	for (int ${6:j} = 0; $6 < $2; ++$6) {
		$4[$5][$6] = ${7:G}[$6][$5];
	}
}
$7 = $4;
endsnippet
snippet util_grid_toguro "grid toguro" b
// グリッドをとぐろ状に進む
//   _______
//   _____  |
//  |   __| |
//  |_______|
//
int y = 0, x = 0; // 始点
int d = 0; // GRID_dydxのインデックスと対応
// for
y += dy[d], x += dx[d]; // d方向に進み続けて
// 領域外、または進めないマスの場合
if (y < 0 or x < 0 or ${1:row} <= y or ${2:col} <= x or !cango(${3:G}[y][x])) {
	y -= dy[d], x -= dx[d]; // やっぱ戻って
	++d, d %= 4; // 方向変えて
	y += dy[d], x += dx[d]; // 進み直す
}
endsnippet
snippet util_grid_bingo "grid bingo" b
// 正方グリッドで
// 縦横ナナメに、そろっているか判定 O(N^2)
// x|o|x   x x x   o x x
// x|o|x   o o o   x o x
// x|o|x   x x x   x x o
vector<int> cx(${1:N}); // クロス1
iota(cx.begin(), cx.end(), 0);
//
vector<int> cy = cx; // クロス2
reverse(cy.begin(), cy.end());
//
bool c1 = true, c2 = true;
//
// 確認する値
${2:int} check_val = ${3:-1};
for (int i = 0; i < $1; ++i) {
	// ナナメを判定
	// o x x
	// x o x
	// x x o
	c1 &= ${4:G}[i][cx[i]] == check_val; // 左上から右下にallmatch
	c2 &= $4[i][cy[i]] == check_val; // 右上から左下にallmatch
	//
	// 縦横を判定
	bool alma = true, alma2 = true;
	for (int j = 0; j < $1; ++j) {
		// x x x
		// o o o  よこ
		alma &= $4[i][j] == check_val; // 行内でallmatch
		// o x x
		// o x x
		// o x x  たて
		alma2 &= $4[j][i] == check_val; // 列内でallmatch
	}
	//
	// alma = i行目の横がビンゴ
	// alma2= i列目の縦がビンゴ
	if (alma or alma2) {
		cout << "row col allmatch" << endl;
	}
}
// c1 = クロス1がビンゴ
// c2 = クロス2がビンゴ
if (c1 or c2) {
	cout << "cross allmatch" << endl;
}
endsnippet

# =========================================================
# input
# =========================================================
snippet in_1 "in 1" b
${1:int} ${2:N};
cin >> $2;
endsnippet
snippet in_1_vec "in 1 + vec" b
${1:int} ${2:N};
cin >> $2;
vector<${3:int}> ${4:A}(${5:$2});
for (int ${6:i} = ${7:0}; $6 <${8:$5}; ++$6) {
	cin >> $4[$6];
}
endsnippet
snippet in_1_q "in 1 + q" b
${1:int} ${2:Q};
cin >> $2;
while ($2--) {
	${3}
}
endsnippet
snippet in_2 "in 2" b
${1:int} ${2:N}, ${3:M};
cin >> $2 >> $3;
endsnippet
snippet in_3 "in 3" b
${1:int} ${2:N}, ${3:M}, ${4:K};
cin >> $2 >> $3 >> $4;
endsnippet
snippet in_4 "in 4" b
${1:int} ${2:N}, ${3:M}, ${4:K}, ${5:S};
cin >> $2 >> $3 >> $4 >> $5;
endsnippet
snippet vec_in_1 "vec in 1" b
vector<${1:int}> ${2:A}(${3:N});
for (int ${4:i} = ${5:0}; $4 <${6:$3}; ++$4) {
	cin >> $2[$4];
}
endsnippet
snippet vec_in_2 "vec in 2" b
vector<${1:int}> ${2:A}(${4:N}), ${3:B}($4);
for (int ${5:i} = ${6:0}; $5 <${7:$4}; ++$5) {
	cin >> $2[$5] >> $3[$5];
}
endsnippet
snippet vec_in_3 "vec in 3" b
vector<${1:int}> ${2:A}(${5:N}), ${3:B}($5), ${4:C}($5);
for (int ${6:i} = ${7:0}; $6 <${8:$5}; ++$6) {
	cin >> $2[$6] >> $3[$6] >> $4[$6];
}
endsnippet
snippet vec_in_4 "vec in 4" b
vector<${1:int}> ${2:A}(${6:N}), ${3:B}($6), ${4:C}($6), ${5:D}($6);
for (int ${7:i} = ${8:0}; $7 <${9:$6}; ++$7) {
	cin >> $2[$7] >> $3[$7] >> $4[$7] >> $5[$7];
}
endsnippet
snippet vec_in_resize "vec in resize" b
vector<vector<${1:int}>> ${2:A}(${3:N});
for (int ${4:i} = ${5:0}; $4 <${6:$3}; ++$4) {
	${7:int} ${8:a};
	cin >> $8;
	$2[$4].resize($8);
	for (int ${9:j} = 0; $9 < $8; ++$9) {
		cin >> $2[$4][$9];
	}
}
endsnippet
snippet grid_in "grid in" b
vector<vector<${1:char}>> ${2:G}(${3:H}, vector<$1>(${4:W}));
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		cin >> $2[i][j];
	}
}
endsnippet
snippet graph_in "graph in" b
vector<vector<${1:int}>> ${2:G}(${3:N});
for (int i = 0; i < ${4:M}; ++i) {
	$1 ${5:A}, ${6:B};
	cin >> $5 >> $6;
	--$5, --$6;
	$2[$5].push_back($6);
	$2[$6].push_back($5);
}
endsnippet
snippet graph_cost_in "graph cost in" b
Graph<${1:long long}> ${2:G}(${3:N});
for (int i = 0; i < ${4:M}; ++i) {
	// 頂点
	int from, to;
	cin >> from >> to;
	--from, --to;
	// コスト
	$1 cost;
	cin >> cost;
	// コストなしの時
	$2.add(from, to);
	$2.add(to, from);
	// コストあり
	$2.add(from, to, cost, i);
	$2.add(to, from, cost, i);
}
endsnippet
snippet edges_cin "edges in" b
Graph<${1:long long}> ${2:G}(${3:N});
vector<Edge<$1>> ${4:E};
for (int i = 0; i < ${5:M}; ++i) {
	// 頂点
	int from, to;
	cin >> from >> to;
	--from, --to;
	// コスト
	$1 cost;
	cin >> cost;
	// コストありグラフ
	$2.add(from, to, cost, i);
	$2.add(to, from, cost, i);
	// 辺
	$4.push_back({from, to, cost, i});
}
endsnippet

# =========================================================
# output
# =========================================================
snippet cout "cout" b
cout << ${1:ans} << endl;
endsnippet
snippet cout_san "cout ternary operator yes no" b
cout << (${1:condition} ? "${2:Yes}" : "${3:No}") << endl;
endsnippet
snippet cout_vec "cout vector" b
for (int ${1:i} = 0; $1 < ${2:N}; ++$1) {
	if ($1) cout << " ";
	cout << ${3:A}[$1];
}
cout << endl;
endsnippet
snippet cout_all "cout all" b
int ${2:_} = 0;
for (auto &&v : ${1:st}) {
	if ($2++) cout << " ";
	cout << v;
}
cout << endl;
endsnippet
snippet cout_grid "cout grid" b
for (int ${1:i} = 0; $1 < ${2:H}; ++$1) {
	for (int ${3:j} = 0; $3 < ${4:W}; ++$3) {
		if ($3) cout << " ";
		cout << ${5:G}[$1][$3];
	}
	cout << endl;
}
endsnippet
snippet cout_endl "endl" b
cout << endl;
endsnippet
snippet cout_fixed_setprecision "fixed setprecision" b
cout << fixed << setprecision(${1:20});
endsnippet

