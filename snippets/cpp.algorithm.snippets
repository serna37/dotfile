#*cpp.algorithm.snippets*        Version 1.0
#==============================================================================
#CONTENTS                                                 *cpp.algorithm*
#
#    Search ......................... |brute force|
#    Binary Search  ................. |binary search|
#    Range .......................... |sequence range algorithm|
#    Sequence ....................... |sequence, others algorithm|
#    BFS ............................ |BFS, grid|
#    DFS ............................ |DFS, tree|
#    DP ............................. |DP transition|
#    Food for thought  .............. |Food for thought|
#
#==============================================================================

# =========================================================
# Algorithm Search
# =========================================================
snippet algo_permu_loop "next permutation" b
// ===========================
// 順列全探索
// O(N!) N < 12程度
do {${2}} while (next_permutation(${1:A}.begin(), $1.end()));
// ソートはしましたか？
endsnippet
snippet algo_permu_dfs_seq "permutation sequence" b
// ===========================
// DFSでの重複順列列挙
// 単調増加ならO(N+M-1 choose M-1) 目安
// N < 10程度
// $4 ~ $5 までの数で、要素数${1:N}の数列を順列全探索
vector<int> ${2:perm}($1);
auto ${3:dfs} = [&](auto &f, int mi, int mx, int last = 0) -> void {
	if (last == $1) {
		// ベースケース
		// 前周までで$1-1要素つくった、今=$1のとき終了
		${6:some}
		return;
	}
	for (int i = mi; i <= mx; ++i) {
		$2[last] = i;
		// 狭義単調増加の場合
		// mi = i + 1;

		// 広義単調増加の場合
		// mi = i;
		f(f, mi, mx, last + 1);
	}
};
$3($3, ${4:1}, ${5:M});
endsnippet
snippet algo_bit_loop "bit loop" b
// ===========================
// bit全探索
// O(2^N) N < 25程度
for (${1:long long} ${2:bit} = 0; $2 < (${3:1ll} << ${4:N}); ++$2) {
	${5:long long} tmp = 0;
	for (int k = 0; k < $4; ++k) {
		// k番目を使うかどうか
		if ($2 & ($3 << k)) {
			tmp |= ${6:A}[k];
		}
	}
}
endsnippet
snippet algo_bit_loop_2 "bit loop" b
// ===========================
// bit全探索
// O(2^N) N < 12程度
for (int bit = 0; bit < (1 << ${1:H}); ++bit) {
	for (int bit2 = 0; bit2 < (1 << ${2:W}); ++bit2) {
		vector<int> ${3:h}, ${4:w};
		for (int k = 0; k < $1; ++k) {
			// $1側の
			// k番目を使う場合、この配列にidx入れてる
			if (bit & (1 << k)) $3.push_back(k);
		}

		for (int k = 0; k < $2; ++k) {
			// $2側の
			// k番目を使う場合、この配列にidx入れてる
			if (bit2 & (1 << k)) $4.push_back(k);
		}
	}
}
endsnippet
snippet algo_bit_n_order "bit N" b
// ===========================
// ${1:N}桁
// ${2:K}進数
// 非再帰 重複順列列挙
// O($2^$1) N < 10程度
vector<int> bit($1, 0);
while (1) {
	for (int i = 0; i < $1; ++i) {
		int tmp = bit[i]; // i桁目の数字（$2進法）
	}
	// インクリメント
	int order = $1 - 1, stop = 0;
	while (1) {
		++bit[order]; // 下1桁目から増やす
		if (bit[order] < $2) break; // くりあげ終了

		// 最大桁が溢れたら全体whileを終了
		if (order == 0) {
			stop = 1;
			break; 
		}

		// 繰り上げるので今の桁は0、次の桁に行く
		bit[order--] = 0;
	}
	if (stop) break;
}
endsnippet
# TODO bit演算系としてまとめ直したい
snippet algo_bit_on_all_pattern "bit on all pattern" b
for (long long i = ${1:N}; i > 0; i = (i - 1) & $1) {
	cout << $1 - i << endl;
}
cout << $1 << endl;
endsnippet
snippet algo_syakutori "syakutori" b
// ===========================
// 尺取法 O(N)
// 連続の和が$4以下である、最大長を求める
// 1. lを固定し、できるだけrを増やす
// 2. 区間をひとつ右に。和の区間から左端が抜ける
// 3. 区間の個数はr-l個
for (int l = 0, r = 0, ${1:sum} = 0; l < ${2:N}; $1 -= ${3:A}[l++]) {
	while (r < $2 and $1 + $3[r] <= ${4:K}) {
		$1 += $3[r++];
	}
	${5:ans} += r - l;
}
endsnippet

# =========================================================
# Algorithm BinarySearch
# =========================================================
snippet algo_bisearch "bisearch" b
// ===========================
// にぶたん O(logN)
auto ${1:test} = [&](${2:long long} x) -> bool {
	// oになる条件を記述
	// x x x o o o o
	//       ↑ここを求める
	${3:return x >= K}
};
// $4: ダメな左側    $5: 満たす右側
$2 ${4:L} = 0, ${5:R} = 1, ${6:MID} = 0;
while (!$1($5)) $5 <<= 1; // 指数探索
while (abs($5 - $4) > 1) ($1($6 = $4 + ($5 - $4) / 2) ? $5 : $4) = $6;
cout << $5 << endl;
endsnippet
snippet algo_bisearch_real_numbers "bisearch R" b
// ===========================
// 実数にぶたん O(logN)
auto ${1:test} = [&](${2:double} x) -> bool {
	// oになる条件を記述
	// x x x o o o o
	//       ↑ここを求める
	${3:return x >= K}
};
// $4: ダメな左側    $5: 満たす右側
$2 ${4:L} = 0, ${5:R} = 1, ${6:MID} = 0;
while (!$1($5)) $5 *= 2; // 指数探索
while (abs($5 - $4) > EPS and abs($5 - $4) / max($5, $4) > EPS)
	($1($6 = $4 + ($5 - $4) / 2) ? $5 : $4) = $6;
cout << $5 << endl;
endsnippet
snippet algo_bi_ika_cnt_idx "ika cnt" b
// $3のうち、$4以下の個数
// $4より大きい最左のidx
${1:int} ${2:cnt} = upper_bound(${3:A}.begin(), $3.end(), ${4:x}) - $3.begin();
endsnippet
snippet algo_bi_sita_cnt_idx "sita cnt" b
// $3のうち、$4より下の個数
// $4以上最左のidx
${1:int} ${2:cnt} = lower_bound(${3:A}.begin(), $3.end(), ${4:x}) - $3.begin();
endsnippet
snippet algo_bi_izyou_cnt "izyou cnt" b
// $3のうち、$4以上の個数
${1:int} ${2:cnt} = ${3:A}.end() - lower_bound($3.begin(), $3.end(), ${4:x});
endsnippet
snippet algo_bi_ue_cnt "ue cnt" b
// $3のうち、$4より大きい個数
${1:int} ${2:cnt} = ${3:A}.end() - upper_bound($3.begin(), $3.end(), ${4:x});
endsnippet
snippet algo_bi_ika_max "0, lim]" b
// $2以下の最右
auto itr = ${1:st}.upper_bound(${2:A});
if (itr == $1.begin()) continue;
--itr;
endsnippet
snippet algo_bi_sita_max "0, lim)" b
// $2より下の最右
auto itr = ${1:st}.lower_bound(${2:A});
if (itr == $1.begin()) continue;
--itr;
endsnippet
snippet algo_bi_izyou_min "[lim, N" b
// $2以上の最左
auto itr = ${1:st}.lower_bound(${2:A});
if (itr == $1.end()) continue;
endsnippet
snippet algo_bi_ue_min "(lim, N" b
// $2より大きい最左
auto itr = ${1:st}.upper_bound(${2:A});
if (itr == $1.end()) continue;
endsnippet

# =========================================================
# Algorithm Range
# =========================================================
snippet algo_zeta "ruisekiwa" b
// ===========================
// 累積和$2_i := $4のi個分の和 (0-indexed)
// ループ、漸化は固定で
// +A[i]以降はカスタムできる
vector<${1:long long}> ${2:S}(${3:N} + 1);
for (int i = 0; i < $3; ++i) {
	$2[i + 1] = $2[i] + ${4:A}[i];
} // $2_i = $4_0 + ... + $4_i-1 →
endsnippet
snippet algo_zeta_rev "ruisekiwa reverse" b
// ===========================
// 累積和$2_i := $4のうしろからi個分の和 (0-indexed)
// rev ループ、漸化は固定で
// +A[i]以降はカスタムできる
vector<${1:long long}> ${2:R}(${3:N} + 1);
for (int i = $3 - 1; i >= 0; --i) {
	$2[i] = $2[i + 1] + ${4:A}[i];
} // $2_i = ← $4_n-i + ... + $4_n-1
endsnippet
snippet algo_zeta_2D "2d ruisekiwa" b
// ===========================
// 2次元ゼータ変換
vector<vector<${1:long long}>> ${2:S}(${3:H} + 1, vector<$1>(${4:W} + 1));
// まず横向きに足す
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		$2[i + 1][j + 1] = $2[i + 1][j] + ${5:A}[i][j];
	}
}
// 次に縦向きに足す
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		$2[i + 1][j + 1] += $2[i][j + 1];
	}
}
endsnippet
snippet algo_moebius "diff" b
vector<${1:int}> ${2:D}(${3:N-1});
for (int i = 0; i < $3; ++i) {
	$2[i] = ${4:A}[i + 1] - $4[i];
}
endsnippet
snippet algo_imos "imos" b
// ===========================
// imos
// 操作区間がlからrなら
// lに足し、r+1から引く
// 末端が配列範囲外なら、操作しなくていい
${3:++}${1:A}[${2:l}];
if ($4 < ${6:N}) ${5:--}$1[${4:r+1}];
// このあと累積和で復元する
endsnippet
snippet algo_imos_2D "2d imos" b
// ===========================
// 2次元imos
// A+1  A | -1
// A    A |
// -1￣￣ +1
// このあと累積和で復元する
endsnippet

# =========================================================
# Algorithm seq
# =========================================================
snippet algo_merge "merge" b
// ===========================
// ${1:A}を${2:B}にマージテク
// amortized O(logN)
if ($1.size() > $2.size()) swap($1, $2);
for (auto &&v : $1) $2.${3:insert}(v);
$1.clear();
endsnippet
snippet algo_zip "zip" b
// ===========================
// 座標圧縮 O(NlogN)
vector<${1:long long}> ${2:cvt} = ${3:target};
// sort重複削除
sort($2.begin(), $2.end());
$2.erase(unique($2.begin(), $2.end()), $2.end());
// 元配列でにぶたんした、idxに変換する(圧縮)
for (auto &v : $3) v = lower_bound($2.begin(), $2.end(), v) - $2.begin();
// 重複削除後の種類数
int ${4:sz} = $2.size();
endsnippet
snippet algo_fwk "fwk" b
// ===========================
// Fenwick Tree O(logN)
// 1-indexedなので注意する
vector<${1:int}> ${2:fwk}(${3:sz+1});
endsnippet
snippet algo_fwk_build "fwk build" b
// ===========================
// Fenwick Treeを配列$4でビルドする
for (int i = 1, f = i + (i & -i); i <= ${1:N}; ++i, f = i + (i & -i)) {
	${2:fwk}[i] ${3:+}= ${4:A}[i - 1];
	if (f <= $1) $2[f] $3= $2[i];
}
endsnippet
snippet algo_fwk_act "fwk act" b
// ===========================
// Fenwick Tree 1点更新
for (int ${1:f} = ${2:1-idx}; $1 <= ${3:N}; $1 += $1 & -$1) ${4:fwk}[$1] ${5:+}= ${6:act_value};
endsnippet
snippet algo_fwk_get "fwk get" b
// ===========================
// Fenwick Tree 区間取得
// $3に値を入れる
for (int ${1:f} = ${2:1-idx}; $1; $1 -= $1 & -$1) ${3:ans} ${4:+}= ${5:fwk}[$1];
endsnippet
snippet algo_seq_inv "seq inv" b
// ===========================
// 転頭数 O(NlogN)
// 右に倒れるA_i > A_j (i < j)の回数
vector<${1:long long}> ${2:cvt} = ${3:A};
// 座標圧縮
sort($2.begin(), $2.end());
$2.erase(unique($2.begin(), $2.end()), $2.end());
for (auto &v : $3) v = lower_bound($2.begin(), $2.end(), v) - $2.begin();
// 圧縮後の種類数
int ${5:sz} = $2.size();
// 追加しながらFenwick Treeの右側を足し上げる
vector<int> ${6:fwk}($5 + 1);
${7:long long} ${8:inv} = 0; // 転倒数
int ${9:R} = $5 - 1; // 座標圧縮したため最大要素 = サイズ-1
for (int i = 0; i < ${10:N}; ++i) {
	// 全区間
	for (int f = $9 + 1; f; f -= f & -f) $8 += $6[f];
	// 今の数以下の個数を引く
	// 今より左側の数列で、今の数「より大きいもの」の個数を数える
	for (int f = $3[i] + 1; f; f -= f & -f) $8 -= $6[f];
	// 今の数をカウント+1
	for (int f = $3[i] + 1; f <= $5; f += f & -f) ++$6[f];
}
endsnippet

# =========================================================
# Algorithm BFS
# =========================================================
snippet algo_bfs "bfs" b
// ===========================
// 単一始点BFS O(N+M)
queue<int> q;
vector<int> dis(${1:N}, -1);
// 始点をセット
q.push(${2:0});
dis[$2] = 0;
while (!q.empty()) {
	int v = q.front();
	q.pop();
	// 連結頂点へ
	for (auto &&nv : ${3:G}[v]) {
		// 初訪問のみ
		if (dis[nv] == -1) {
			// 距離+1
			dis[nv] = dis[v] + 1;
			q.push(nv);
		}
	}
}
endsnippet
snippet algo_bfs_multi_start "bfs multi start" b
// ===========================
// 複数始点BFS O(N+M)
queue<int> q;
vector<int> dis(${1:N}, -1);
// 複数の始点をセットする
for (int i = 0; i < ${2:K}; ++i) {
	q.push(${3:C[i]});
	dis[$3] = 0;
}
while (!q.empty()) {
	int v = q.front();
	q.pop();
	// 連結頂点へ
	for (auto &&nv : ${4:G}[v]) {
		// 初訪問のみ
		if (dis[nv] == -1) {
			// 距離+1
			dis[nv] = dis[v] + 1;
			q.push(nv);
		}
	}
}
endsnippet
snippet algo_bfs_grid "bfs grid" b
// ===========================
// 単一始点グリッドBFS O(N+M)
queue<pair<int, int>> q;
// 始点の座標
q.push({${1:sy}, ${2:sx}});
vector<vector<int>> dis(${3:H}, vector<int>(${4:W}, -1));
// 始点は距離0
dis[$1][$2] = 0;
while (!q.empty()) {
	// 今の点の座標
	auto [py, px] = q.front();
	q.pop();
	// 4方グリッドへすすむ
	for (int i = 0; i < 4; ++i) {
		int y = py + dy[i], x = px + dx[i];

		// 領域外なら無視
		if (y < 0 or x < 0 or $3 <= y or $4 <= x) continue;

		// 初訪問かつ、行けるマスであれば
		if (dis[y][x] == -1 and cango(${5:G}[y][x])) {
			// 距離+1
			dis[y][x] = dis[py][px] + 1;
			q.push({y, x});
		}
	}
}
endsnippet
snippet algo_grid_dydx "dydx" b
// ===========================
int y = ${1:i}, x = ${2:j}; // 始点とする
y += dy[${3:d}], x += dx[$3]; // マス移動する
endsnippet
snippet algo_grid_filter "bfs grid filter" b
// 領域外
if (${1:y} < 0 or ${2:x} < 0 or ${3:row} <= $1 or ${4:col} <= $2) ${5:continue};
endsnippet
snippet algo_grid_cango "grid cango" b
// ===========================
// 進めるか判定する関数
auto cango = [](const char &a) -> bool {
	string white = "${1:.SG}";
	return white.find(a) != string::npos;
};
endsnippet
snippet algo_grid_toguro "toguro" b
// ===========================
// グリッドをとぐろ状に進む
// 始点、方向d
int y = 0, x = 0, d = 0; // GRID_dydxのインデックスと対応
for
y += dy[d], x += dx[d]; // d方向に進む
// 領域外、または進めないマスの場合
if (y < 0 or x < 0 or ${1:row} <= y or ${2:col} <= x or G[y][x] != -1) {
	y -= dy[d], x -= dx[d]; // やっぱ戻って
	++d, d %= 4; // 方向変えて
	y += dy[d], x += dx[d]; // 進み直す
}
endsnippet
snippet algo_grid_bingo "bingo" b
// ===========================
// 縦横ナナメに、そろっているか判定
vector<int> cx(${1:N}); // クロス1
iota(cx.begin(), cx.end(), 0);

vector<int> cy = cx; // クロス2
reverse(cy.begin(), cy.end());

bool c1 = true, c2 = true;

// 確認する値
${2:int} check_val = ${3:-1};
for (int i = 0; i < $1; ++i) {
	// ナナメを判定
	c1 &= ${4:A}[i][cx[i]] == check_val; // 左上から右下にallmatch
	c2 &= $4[i][cy[i]] == check_val; // 右上から左下にallmatch

	// 縦横を判定
	bool alma = true, alma2 = true;
	for (int j = 0; j < $1; ++j) {
		alma &= $4[i][j] == check_val; // 行内でallmatch
		alma2 &= $4[j][i] == check_val; // 列内でallmatch
	}

	if (alma or alma2) {
		cout << "TODO row col allmatch" << endl;
	}
}
if (c1 or c2) {
	cout << "TODO cross allmatch" << endl;
}
endsnippet

# =========================================================
# Algorithm DFS
# =========================================================
snippet algo_dfs "dfs" b
// ===========================
// DFS O(N+M)
vector<bool> seen(${1:N}, false);
auto dfs = [&](auto &f, int v) -> void {
	// 行きがけ
	seen[v] = true;
	for (auto &&nv : ${2:G}[v]) {
		if (seen[nv]) continue;
		f(f, nv);
	}
	// 帰りがけ
};
dfs(dfs, ${3:0});
endsnippet
snippet algo_dfs_tree "dfs" b
// ===========================
// 木の深さDFS O(N+M)
vector<int> depth(N);
auto dfs = [&](auto &f, int v, int p, int d) -> void {
	// 行きがけ
	depth[v] = d;
	for (int nv : ${1:G}[v]) {
		if (nv == p) continue;
		f(f, nv, v, d + 1);
	}
	// 帰りがけ
};
dfs(dfs, ${2:root}, -1, 0);
endsnippet

# =========================================================
# Algorithm DP
# =========================================================
snippet algo_dp "dp" b
// ===========================
// 成果物の時間順な状態管理
// i番目の行での${1:M}個の状態
${2:vector<int>} ${3:def}($1+1, ${4:INF});
auto dp = $3, nx = dp; // 今行をdp、次行をnx
algo_dp_ini
endsnippet
snippet algo_dp_ini "dp ini" b
// ===========================
dp[${1:0}] = ${2:0};
algo_dp_for
endsnippet
snippet algo_dp_for "dp for" b
// ===========================
for (int i = 0; i < ${1:N}; ++i, swap(dp, nx)) {
	// 今行を次行に遷移し、行を埋める
	// 選ばない場合の、緩和や通り数の加算はnx=dp
	// 必ず選ぶ場合、初期化行にしたい場合nx=def
	nx = ${2:dp def};
	// 漸化式部分
	${3}
}
// 最終行はdp
endsnippet
snippet algo_dp_add "dp add" b
// ===========================
// dp_j  dp_$1
//      ↘︎ ↓
// nx_j  nx_$1
nx[${1:j + 1}] += dp[${2:j}];
endsnippet
snippet algo_dp_chdp "chdp knapsack" b
// ===========================
// dp_from   dp(nx=dpで緩和済み)
//    +cost ↘︎  ↓
//          nx_to
nx[${3:to}] = ${1:min}(nx[$3], dp[${2:from}] + ${4:cost});
endsnippet
snippet algo_dp_seg "dp seg" b
// ===========================
SegTree<${1:Mmin}<${2:long long}>> ${3:dp}(${4:区間長} + 1);
$3.set(${5:0}, ${6:初期コスト});
endsnippet
snippet algo_dp_chdp_seg "chdp seg" b
// ===========================
// | dp_l  dp_l+1  ... dp_r-1 | dp_r  ...
//      ↘︎ ↘︎ ↓ ↓ ↙︎ ↙︎  区間取得+cost
//         dp_to   と緩和
${1:dp}.set(${4:to}, ${2:min}($1[$4], $1.get(${3:from l, r}) + ${5:cost}));
endsnippet

# TODO 遷移式メインに修正中

snippet algo_dp_knapsack_alt "dp knapsack alt" b
// TODO これ理解したら汎用化したいね
int ${1:V} = ${2:1e5};
vector<vector<${3:int}>> dp(${4:N} + 1, vector<$3>($1 + 1, inf<$3>));
dp[0][0] = 0;
for (int i = 0; i < $4; ++i) {
	for (int j = 0; j <= $1; ++j) {
		dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);
		if (v[i] <= j) {
			dp[i + 1][j] = min(dp[i + 1][j], dp[i][j - ${5:v}[i]] + ${6:w}[i]);
		}
	}
}
$3 ans = 0;
for (int i = 0; i <= $1; ++i) {
	if (dp[$4][i] <= ${7:W}) {
		ans = max(ans, i);
	}
}
cout << ans << endl;
endsnippet

snippet algo_dp_lcs "dp lcs" b
// WIP これは長さだけ。本体を求めるものもある
// LCS
int ${3:s} = ${1:S}.size(), ${4:t} = ${2:T}.size();
vector<vector<int>> dp($3 + 1, vector<int>($4 + 1, 0));
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		dp[i + 1][j + 1] = max(
			{dp[i][j + 1], dp[i + 1][j], dp[i][j] + ($1[i] == $2[j])});
	}
}
cout << dp[$3][$4] << endl;
endsnippet
snippet algo_dp_lis "dp lis" b
// WIP
// LIS
endsnippet
snippet algo_dp_order "dp order" b
// WIP
// 桁DP
endsnippet
snippet algo_dp_range "dp range" b
// WIP
// 区間DP
endsnippet
snippet algo_dp_bit "dp bit" b
// WIP
// bit集合DP
endsnippet
snippet algo_dp_tree "dp tree" b
// TODO
// 頂点vの部分木を対象とした木DP
vector<${1:long long}> dp(${2:N}, ${3:0});
auto dfs = [&](auto &f, int v, int par = -1) -> void {
	if (${4:tree}[v].size() == 1) {
		dp[v] = 0;
		return;
	}
	$1 tmp = 0;
	for (auto &&[from, to, cost, id] : $4[v]) {
		if (to == par) continue;
		f(f, to, from);
		tmp = ${5:max}(tmp, dp[to] + cost);
	}
	dp[v] = tmp;
};
dfs(dfs, N);
cout << dp[N - 1] << endl;
endsnippet
snippet algo_dp_rerooting "dp rerooting" b
// WIP
// 全方位木DP
endsnippet

# =========================================================
# Food for thought
# =========================================================
snippet serna37 "food for thought" bi
[ ☠️  バグ狩り典型 ]
- 掛け算          :溢れないよう割る
- 引き算          :割り算
- 誤差            :A < BはA < B - EPS
- 配列外参照      :最小が0以下、最大がN-1
- 0除算           :割る数が0になるか考慮
- オーバーフロー  :long longにしなさい
- コーナーケース  :0のとき、1のとき、末端
- 嘘貪欲          :漸化式ができるならDP
- DP初期化忘れ、ループ範囲不足はないか？
- ◯個のはず、はやめて明確な条件まで愚直ループ

[ ⚙️  探索空間の典型考察 ]
- 全域で探索　線形なら間に合う
- 答えの候補を探索
- 答えに寄与する部分を考慮
- パラーメタを片方固定する
- パラメータ3つの時は真ん中を固定する
- N倍ずつループ、◯ 乗限界でループ

[ 🔥 性質の典型考察：高速化・前計算 ]
- 二分探索
  - 答えの候補に単調性
  - 小さい方からK番目
- 累積和
- 包除原理
- 式変形
  - 添え字を揃える　A_i + i = A_j + j
  - i < jで「より小さい」今までの値から数え上げ
    - → 単調性があれば二分探索
    -   なければ圧縮Fenwick
    - → 計上後にvec map追加
- 区間クエリ
  - idxを管理し二分探索
  - セグ木 モノイドを改造
- その他
  - パリティで分ける
  - 対偶を計算して引く
  - 極端な場合を考えてみる
  - 主客転倒　配列、時間を逆向きに計上
  - 双方向リストはmap2個
  - 制約が指数時間を許す→ 力技をまず先に
  - 制約が線形ギリすぎる最適化→ DPは貪欲かも
endsnippet

