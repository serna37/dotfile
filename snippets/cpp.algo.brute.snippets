# =========================================================
# Brute Force
# - 順列全探索
# - bit全探索
# =========================================================

# 順列
snippet algo_brute_permutation "順列全探索" b
sort(${1:A}.begin(), $1.end());
do {
	${2}
} while (next_permutation($1.begin(), $1.end()));
endsnippet
snippet algo_brute_permutation_dfs_seq "DFS重複順列列挙" b
// 広義単調増加の組み合わせは N + M - 1 C M
// $4 ~ $5 までの数で要素数${1:N}の数列を順列全探索 単調増加でN<13程度
vector<int> ${2:perm}($1);
auto ${3:dfs} = [&](auto &f, int mi, int mx, int last = 0) -> void {
	if (last == $1) {
		// ベースケース 前まで$1-1個作、今=$1で終了
		${6:some}
		return;
	}
	for (int i = mi; i <= mx; ++i) {
		$2[last] = i;
		// 狭義単調増加 1 2 3 4 5
		// mi = i + 1;
		// 広義単調増加 1 1 2 3 4 被りok
		// mi = i;
		f(f, mi, mx, last + 1);
	}
};
$3($3, ${4:1}, ${5:M});
endsnippet

# bit全探索
snippet algo_brute_bit_loop "bit全探索" b
for (${1:long long} ${2:bit} = 0; $2 < (${3:1ll} << ${4:N}); ++$2) {
	${5:long long} tmp = 0;
	for (int k = 0; k < $4; ++k) {
		// k番目を使うかどうか
		if ($2 & ($3 << k)) {
			tmp |= ${6:A}[k];
		}
	}
}
endsnippet
snippet algo_brute_bit_loop_2 "bit全探索 2重" b
for (int bit = 0; bit < (1 << ${1:H}); ++bit) {
	for (int bit2 = 0; bit2 < (1 << ${2:W}); ++bit2) {
		vector<int> ${3:h}, ${4:w};
		for (int k = 0; k < $1; ++k) {
			// $1側の
			// k番目を使う場合、この配列にidx入れてる
			if (bit & (1 << k)) $3.push_back(k);
		}
		//
		for (int k = 0; k < $2; ++k) {
			// $2側の
			// k番目を使う場合、この配列にidx入れてる
			if (bit2 & (1 << k)) $4.push_back(k);
		}
		//
		// h = {0, 1} 行目と
		// w = {0} 列目が選ばれている
	}
}
endsnippet

# その他
snippet algo_brute_bit_n_order "K進法N桁全探索" b
// bit全探索 非再帰 重複順列列挙 O($2^$1) N < 10程度
// ${1:N}桁 ${2:K}進数
vector<int> bit($1, 0);
// bit = {0,0,0}, {0,0,1}, {0,1,0}, {0,1,1} ...
while (1) {
	// bit = {1,1,0} を左から見るループ
	for (int i = 0; i < $1; ++i) {
		int tmp = bit[i]; // i桁目の数字（$2進法）
	}
	// インクリメント
	int order = $1 - 1, stop = 0;
	while (1) {
		++bit[order]; // 下1桁目から増やす
		if (bit[order] < $2) break; // くりあげ終了
		// 最大桁が溢れたら全体whileを終了
		if (order == 0) {
			stop = 1;
			break;
		}
		// 繰り上げるので今の桁は0、次の桁に行く
		bit[order--] = 0;
	}
	if (stop) break;
}
endsnippet

# TODO bit演算系としてまとめ直したい
snippet algo_brute_bit_on_all_pattern "bit on all pattern" b
for (long long i = ${1:N}; i > 0; i = (i - 1) & $1) {
	cout << $1 - i << endl;
}
cout << $1 << endl;
endsnippet

