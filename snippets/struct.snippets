# =========================================================
# UnionFind
# =========================================================
snippet ww_struct_uf "union find" b
struct UnionFind {
  private:
	int N;
	vector<int> par;

  public:
	UnionFind(int N) : N(N), par(N) {
		iota(par.begin(), par.end(), 0);
	}
	int getRoot(const int &i) {
		return par[i] == i ? i : par[i] = getRoot(par[i]);
	}
	void unite(int x, int y) {
		int rx = getRoot(x), ry = getRoot(y);
		if (rx == ry) return;
		par[rx] = ry;
	}
	bool isSameRoot(int x, int y) {
		return getRoot(x) == getRoot(y);
	}
	bool isRoot(int i) {
		return getRoot(i) == i;
	}
	int getRootCnt() {
		int cnt = 0;
		for (int i = 0; i < N; i++) {
			if (isRoot(i)) cnt++;
		}
		return cnt;
	}
};
endsnippet

#Spares table
# Wavelet Matrix

snippet ww_graph_dijkstra "dijkstra" b
template <typename T, typename Graph>
pair<vector<T>, vector<int>> dijkstra(const Graph &G, int s) {
    int N = G.size();
    using P = pair<int, T>;
    priority_queue<P, vector<P>, greater<P>> q;
    q.emplace(s, 0);
    vector<T> dist(N, inf<T>);
    dist[s] = 0;
    vector<int> route(N, -1);
    while (!q.empty()) {
        auto [v, dv] = q.top();
        q.pop();
        if (dist[v] < dv) continue;
        for (auto n : G[v]) {
            int nv = n.first, cost = n.second;
            if (dist[nv] > dist[v] + cost) {
                dist[nv] = dist[v] + cost;
                q.emplace(nv, dist[nv]);
                route[nv] = v;
            }
        }
    }
    return {dist, route};
}
endsnippet

snippet ww_struct_datetime "datetime" b
struct DateTime {
    int year, month, day;
    DateTime() : year(0), month(0), day(0){};
    DateTime(int m) : year(0), month(m), day(0){};
    DateTime(int y, int m, int d) : year(y), month(m), day(d){};
    static constexpr int month_days[13] = {0,  31, 28, 31, 30, 31, 30,
                                           31, 31, 30, 31, 30, 31};
    // 月の日数
    int dpm(int m) {
        if (is_leap_year(year) and m == 2) return 29;
        return month_days[m];
    }
    // 1年1月1日が 0 となるように変換
    int to_int() {
        int y = (month <= 2 ? year - 1 : year);
        int m = (month <= 2 ? month + 12 : month);
        int d = day;
        return 365 * y + y / 4 - y / 100 + y / 400 + 306 * (m + 1) / 10 + d -
               429;
    }
    // to_int() の逆関数
    static DateTime from_int(int x) {
        int y = x * 400 / 146097 + 1;
        int d = x - DateTime(y, 1, 1).to_int();
        int m = 1;
        while (d >= 28) {
            int k = month_days[m] + (m == 2 && is_leap_year(y) ? 1 : 0);
            if (d < k) break;
            ++m;
            d -= k;
        }
        if (m == 13) {
            ++y;
            m = 1;
        }
        ++d;
        return DateTime(y, m, d);
    }
    // 日曜日が 0 として、曜日を [0, 7) で返す
    int weekday() {
        return (to_int() + 1) % 7;
    }
    DateTime &operator++() {
        ++day;
        int lim = month_days[month];
        if (is_leap_year(year) && month == 2) lim = 29;
        if (day <= lim) return (*this);
        day = 1;
        ++month;
        if (month == 13) {
            ++year;
            month = 1;
        }
        return (*this);
    }
    DateTime operator++(int) {
        DateTime tmp = *this;
        ++*this;
        return tmp;
    }
    bool operator==(DateTime const &rhs) const {
        return to_tuple() == rhs.to_tuple();
    }
    bool operator!=(DateTime const &rhs) const {
        return to_tuple() != rhs.to_tuple();
    }
    bool operator<(DateTime const &rhs) const {
        return to_tuple() < rhs.to_tuple();
    }
    bool operator<=(DateTime const &rhs) const {
        return to_tuple() <= rhs.to_tuple();
    }
    bool operator>(DateTime const &rhs) const {
        return to_tuple() > rhs.to_tuple();
    }
    bool operator>=(DateTime const &rhs) const {
        return to_tuple() >= rhs.to_tuple();
    }
    // yyyy[sep]mm[sep]dd
    string to_string(string sep = "-") {
        string y = std::to_string(year);
        string m = std::to_string(month);
        string d = std::to_string(day);
        while ((int)y.size() < 4) y = "0" + y;
        while ((int)m.size() < 2) m = "0" + m;
        while ((int)d.size() < 2) d = "0" + d;
        return y + sep + m + sep + d;
    }
    tuple<int, int, int> to_tuple() const {
        return {year, month, day};
    }
    static bool is_leap_year(int y) {
        if (y % 400 == 0) return true;
        return (y % 4 == 0 && y % 100 != 0);
    }
    static bool is_valid_date(int y, int m, int d) {
        if (!(1 <= m && m <= 12)) return 0;
        int mx = month_days[m];
        if (m == 2 && is_leap_year(y)) ++mx;
        return (1 <= d && d <= mx);
    }
};
endsnippet


